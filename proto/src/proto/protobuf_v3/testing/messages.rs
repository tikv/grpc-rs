// This file is generated by rust-protobuf 3.2.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `grpc/testing/messages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobufv3::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.BoolValue)
pub struct BoolValue {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.BoolValue.value)
    pub value: bool,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.BoolValue.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BoolValue {
    fn default() -> &'a BoolValue {
        <BoolValue as ::protobufv3::Message>::default_instance()
    }
}

impl BoolValue {
    pub fn new() -> BoolValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &BoolValue| { &m.value },
            |m: &mut BoolValue| { &mut m.value },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<BoolValue>(
            "BoolValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for BoolValue {
    const NAME: &'static str = "BoolValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = is.read_bool()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != false {
            my_size += 1 + 1;
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.value != false {
            os.write_bool(1, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BoolValue {
        BoolValue::new()
    }

    fn clear(&mut self) {
        self.value = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BoolValue {
        static instance: BoolValue = BoolValue {
            value: false,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for BoolValue {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BoolValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BoolValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for BoolValue {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.Payload)
pub struct Payload {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.Payload.type)
    pub type_: ::protobufv3::EnumOrUnknown<PayloadType>,
    // @@protoc_insertion_point(field:grpc.testing.Payload.body)
    pub body: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.Payload.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Payload {
    fn default() -> &'a Payload {
        <Payload as ::protobufv3::Message>::default_instance()
    }
}

impl Payload {
    pub fn new() -> Payload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Payload| { &m.type_ },
            |m: &mut Payload| { &mut m.type_ },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "body",
            |m: &Payload| { &m.body },
            |m: &mut Payload| { &mut m.body },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<Payload>(
            "Payload",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for Payload {
    const NAME: &'static str = "Payload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.body = is.read_bytes()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobufv3::EnumOrUnknown::new(PayloadType::COMPRESSABLE) {
            my_size += ::protobufv3::rt::int32_size(1, self.type_.value());
        }
        if !self.body.is_empty() {
            my_size += ::protobufv3::rt::bytes_size(2, &self.body);
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.type_ != ::protobufv3::EnumOrUnknown::new(PayloadType::COMPRESSABLE) {
            os.write_enum(1, ::protobufv3::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.body.is_empty() {
            os.write_bytes(2, &self.body)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Payload {
        Payload::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobufv3::EnumOrUnknown::new(PayloadType::COMPRESSABLE);
        self.body.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Payload {
        static instance: Payload = Payload {
            type_: ::protobufv3::EnumOrUnknown::from_i32(0),
            body: ::std::vec::Vec::new(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for Payload {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Payload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Payload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for Payload {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.EchoStatus)
pub struct EchoStatus {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.EchoStatus.code)
    pub code: i32,
    // @@protoc_insertion_point(field:grpc.testing.EchoStatus.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.EchoStatus.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EchoStatus {
    fn default() -> &'a EchoStatus {
        <EchoStatus as ::protobufv3::Message>::default_instance()
    }
}

impl EchoStatus {
    pub fn new() -> EchoStatus {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &EchoStatus| { &m.code },
            |m: &mut EchoStatus| { &mut m.code },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &EchoStatus| { &m.message },
            |m: &mut EchoStatus| { &mut m.message },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<EchoStatus>(
            "EchoStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for EchoStatus {
    const NAME: &'static str = "EchoStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_int32()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobufv3::rt::int32_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobufv3::rt::string_size(2, &self.message);
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EchoStatus {
        EchoStatus::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EchoStatus {
        static instance: EchoStatus = EchoStatus {
            code: 0,
            message: ::std::string::String::new(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for EchoStatus {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EchoStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EchoStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for EchoStatus {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.SimpleRequest)
pub struct SimpleRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.SimpleRequest.response_type)
    pub response_type: ::protobufv3::EnumOrUnknown<PayloadType>,
    // @@protoc_insertion_point(field:grpc.testing.SimpleRequest.response_size)
    pub response_size: i32,
    // @@protoc_insertion_point(field:grpc.testing.SimpleRequest.payload)
    pub payload: ::protobufv3::MessageField<Payload>,
    // @@protoc_insertion_point(field:grpc.testing.SimpleRequest.fill_username)
    pub fill_username: bool,
    // @@protoc_insertion_point(field:grpc.testing.SimpleRequest.fill_oauth_scope)
    pub fill_oauth_scope: bool,
    // @@protoc_insertion_point(field:grpc.testing.SimpleRequest.response_compressed)
    pub response_compressed: ::protobufv3::MessageField<BoolValue>,
    // @@protoc_insertion_point(field:grpc.testing.SimpleRequest.response_status)
    pub response_status: ::protobufv3::MessageField<EchoStatus>,
    // @@protoc_insertion_point(field:grpc.testing.SimpleRequest.expect_compressed)
    pub expect_compressed: ::protobufv3::MessageField<BoolValue>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.SimpleRequest.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SimpleRequest {
    fn default() -> &'a SimpleRequest {
        <SimpleRequest as ::protobufv3::Message>::default_instance()
    }
}

impl SimpleRequest {
    pub fn new() -> SimpleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response_type",
            |m: &SimpleRequest| { &m.response_type },
            |m: &mut SimpleRequest| { &mut m.response_type },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response_size",
            |m: &SimpleRequest| { &m.response_size },
            |m: &mut SimpleRequest| { &mut m.response_size },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, Payload>(
            "payload",
            |m: &SimpleRequest| { &m.payload },
            |m: &mut SimpleRequest| { &mut m.payload },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fill_username",
            |m: &SimpleRequest| { &m.fill_username },
            |m: &mut SimpleRequest| { &mut m.fill_username },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fill_oauth_scope",
            |m: &SimpleRequest| { &m.fill_oauth_scope },
            |m: &mut SimpleRequest| { &mut m.fill_oauth_scope },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, BoolValue>(
            "response_compressed",
            |m: &SimpleRequest| { &m.response_compressed },
            |m: &mut SimpleRequest| { &mut m.response_compressed },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, EchoStatus>(
            "response_status",
            |m: &SimpleRequest| { &m.response_status },
            |m: &mut SimpleRequest| { &mut m.response_status },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, BoolValue>(
            "expect_compressed",
            |m: &SimpleRequest| { &m.expect_compressed },
            |m: &mut SimpleRequest| { &mut m.expect_compressed },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<SimpleRequest>(
            "SimpleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for SimpleRequest {
    const NAME: &'static str = "SimpleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response_type = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.response_size = is.read_int32()?;
                },
                26 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.payload)?;
                },
                32 => {
                    self.fill_username = is.read_bool()?;
                },
                40 => {
                    self.fill_oauth_scope = is.read_bool()?;
                },
                50 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.response_compressed)?;
                },
                58 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.response_status)?;
                },
                66 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.expect_compressed)?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.response_type != ::protobufv3::EnumOrUnknown::new(PayloadType::COMPRESSABLE) {
            my_size += ::protobufv3::rt::int32_size(1, self.response_type.value());
        }
        if self.response_size != 0 {
            my_size += ::protobufv3::rt::int32_size(2, self.response_size);
        }
        if let Some(v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if self.fill_username != false {
            my_size += 1 + 1;
        }
        if self.fill_oauth_scope != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.response_compressed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.response_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.expect_compressed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.response_type != ::protobufv3::EnumOrUnknown::new(PayloadType::COMPRESSABLE) {
            os.write_enum(1, ::protobufv3::EnumOrUnknown::value(&self.response_type))?;
        }
        if self.response_size != 0 {
            os.write_int32(2, self.response_size)?;
        }
        if let Some(v) = self.payload.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.fill_username != false {
            os.write_bool(4, self.fill_username)?;
        }
        if self.fill_oauth_scope != false {
            os.write_bool(5, self.fill_oauth_scope)?;
        }
        if let Some(v) = self.response_compressed.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.response_status.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.expect_compressed.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SimpleRequest {
        SimpleRequest::new()
    }

    fn clear(&mut self) {
        self.response_type = ::protobufv3::EnumOrUnknown::new(PayloadType::COMPRESSABLE);
        self.response_size = 0;
        self.payload.clear();
        self.fill_username = false;
        self.fill_oauth_scope = false;
        self.response_compressed.clear();
        self.response_status.clear();
        self.expect_compressed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SimpleRequest {
        static instance: SimpleRequest = SimpleRequest {
            response_type: ::protobufv3::EnumOrUnknown::from_i32(0),
            response_size: 0,
            payload: ::protobufv3::MessageField::none(),
            fill_username: false,
            fill_oauth_scope: false,
            response_compressed: ::protobufv3::MessageField::none(),
            response_status: ::protobufv3::MessageField::none(),
            expect_compressed: ::protobufv3::MessageField::none(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for SimpleRequest {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SimpleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SimpleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for SimpleRequest {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.SimpleResponse)
pub struct SimpleResponse {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.SimpleResponse.payload)
    pub payload: ::protobufv3::MessageField<Payload>,
    // @@protoc_insertion_point(field:grpc.testing.SimpleResponse.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.testing.SimpleResponse.oauth_scope)
    pub oauth_scope: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.SimpleResponse.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SimpleResponse {
    fn default() -> &'a SimpleResponse {
        <SimpleResponse as ::protobufv3::Message>::default_instance()
    }
}

impl SimpleResponse {
    pub fn new() -> SimpleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, Payload>(
            "payload",
            |m: &SimpleResponse| { &m.payload },
            |m: &mut SimpleResponse| { &mut m.payload },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &SimpleResponse| { &m.username },
            |m: &mut SimpleResponse| { &mut m.username },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oauth_scope",
            |m: &SimpleResponse| { &m.oauth_scope },
            |m: &mut SimpleResponse| { &mut m.oauth_scope },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<SimpleResponse>(
            "SimpleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for SimpleResponse {
    const NAME: &'static str = "SimpleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.payload)?;
                },
                18 => {
                    self.username = is.read_string()?;
                },
                26 => {
                    self.oauth_scope = is.read_string()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.username.is_empty() {
            my_size += ::protobufv3::rt::string_size(2, &self.username);
        }
        if !self.oauth_scope.is_empty() {
            my_size += ::protobufv3::rt::string_size(3, &self.oauth_scope);
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if let Some(v) = self.payload.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.username.is_empty() {
            os.write_string(2, &self.username)?;
        }
        if !self.oauth_scope.is_empty() {
            os.write_string(3, &self.oauth_scope)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SimpleResponse {
        SimpleResponse::new()
    }

    fn clear(&mut self) {
        self.payload.clear();
        self.username.clear();
        self.oauth_scope.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SimpleResponse {
        static instance: SimpleResponse = SimpleResponse {
            payload: ::protobufv3::MessageField::none(),
            username: ::std::string::String::new(),
            oauth_scope: ::std::string::String::new(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for SimpleResponse {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SimpleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SimpleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for SimpleResponse {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.StreamingInputCallRequest)
pub struct StreamingInputCallRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.StreamingInputCallRequest.payload)
    pub payload: ::protobufv3::MessageField<Payload>,
    // @@protoc_insertion_point(field:grpc.testing.StreamingInputCallRequest.expect_compressed)
    pub expect_compressed: ::protobufv3::MessageField<BoolValue>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.StreamingInputCallRequest.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamingInputCallRequest {
    fn default() -> &'a StreamingInputCallRequest {
        <StreamingInputCallRequest as ::protobufv3::Message>::default_instance()
    }
}

impl StreamingInputCallRequest {
    pub fn new() -> StreamingInputCallRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, Payload>(
            "payload",
            |m: &StreamingInputCallRequest| { &m.payload },
            |m: &mut StreamingInputCallRequest| { &mut m.payload },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, BoolValue>(
            "expect_compressed",
            |m: &StreamingInputCallRequest| { &m.expect_compressed },
            |m: &mut StreamingInputCallRequest| { &mut m.expect_compressed },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<StreamingInputCallRequest>(
            "StreamingInputCallRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for StreamingInputCallRequest {
    const NAME: &'static str = "StreamingInputCallRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.payload)?;
                },
                18 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.expect_compressed)?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.expect_compressed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if let Some(v) = self.payload.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.expect_compressed.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamingInputCallRequest {
        StreamingInputCallRequest::new()
    }

    fn clear(&mut self) {
        self.payload.clear();
        self.expect_compressed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamingInputCallRequest {
        static instance: StreamingInputCallRequest = StreamingInputCallRequest {
            payload: ::protobufv3::MessageField::none(),
            expect_compressed: ::protobufv3::MessageField::none(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for StreamingInputCallRequest {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamingInputCallRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamingInputCallRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for StreamingInputCallRequest {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.StreamingInputCallResponse)
pub struct StreamingInputCallResponse {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.StreamingInputCallResponse.aggregated_payload_size)
    pub aggregated_payload_size: i32,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.StreamingInputCallResponse.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamingInputCallResponse {
    fn default() -> &'a StreamingInputCallResponse {
        <StreamingInputCallResponse as ::protobufv3::Message>::default_instance()
    }
}

impl StreamingInputCallResponse {
    pub fn new() -> StreamingInputCallResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "aggregated_payload_size",
            |m: &StreamingInputCallResponse| { &m.aggregated_payload_size },
            |m: &mut StreamingInputCallResponse| { &mut m.aggregated_payload_size },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<StreamingInputCallResponse>(
            "StreamingInputCallResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for StreamingInputCallResponse {
    const NAME: &'static str = "StreamingInputCallResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.aggregated_payload_size = is.read_int32()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.aggregated_payload_size != 0 {
            my_size += ::protobufv3::rt::int32_size(1, self.aggregated_payload_size);
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.aggregated_payload_size != 0 {
            os.write_int32(1, self.aggregated_payload_size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamingInputCallResponse {
        StreamingInputCallResponse::new()
    }

    fn clear(&mut self) {
        self.aggregated_payload_size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamingInputCallResponse {
        static instance: StreamingInputCallResponse = StreamingInputCallResponse {
            aggregated_payload_size: 0,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for StreamingInputCallResponse {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamingInputCallResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamingInputCallResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for StreamingInputCallResponse {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ResponseParameters)
pub struct ResponseParameters {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.ResponseParameters.size)
    pub size: i32,
    // @@protoc_insertion_point(field:grpc.testing.ResponseParameters.interval_us)
    pub interval_us: i32,
    // @@protoc_insertion_point(field:grpc.testing.ResponseParameters.compressed)
    pub compressed: ::protobufv3::MessageField<BoolValue>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ResponseParameters.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseParameters {
    fn default() -> &'a ResponseParameters {
        <ResponseParameters as ::protobufv3::Message>::default_instance()
    }
}

impl ResponseParameters {
    pub fn new() -> ResponseParameters {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &ResponseParameters| { &m.size },
            |m: &mut ResponseParameters| { &mut m.size },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "interval_us",
            |m: &ResponseParameters| { &m.interval_us },
            |m: &mut ResponseParameters| { &mut m.interval_us },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, BoolValue>(
            "compressed",
            |m: &ResponseParameters| { &m.compressed },
            |m: &mut ResponseParameters| { &mut m.compressed },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ResponseParameters>(
            "ResponseParameters",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ResponseParameters {
    const NAME: &'static str = "ResponseParameters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.size = is.read_int32()?;
                },
                16 => {
                    self.interval_us = is.read_int32()?;
                },
                26 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.compressed)?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.size != 0 {
            my_size += ::protobufv3::rt::int32_size(1, self.size);
        }
        if self.interval_us != 0 {
            my_size += ::protobufv3::rt::int32_size(2, self.interval_us);
        }
        if let Some(v) = self.compressed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.size != 0 {
            os.write_int32(1, self.size)?;
        }
        if self.interval_us != 0 {
            os.write_int32(2, self.interval_us)?;
        }
        if let Some(v) = self.compressed.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseParameters {
        ResponseParameters::new()
    }

    fn clear(&mut self) {
        self.size = 0;
        self.interval_us = 0;
        self.compressed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseParameters {
        static instance: ResponseParameters = ResponseParameters {
            size: 0,
            interval_us: 0,
            compressed: ::protobufv3::MessageField::none(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ResponseParameters {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseParameters").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ResponseParameters {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.StreamingOutputCallRequest)
pub struct StreamingOutputCallRequest {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.StreamingOutputCallRequest.response_type)
    pub response_type: ::protobufv3::EnumOrUnknown<PayloadType>,
    // @@protoc_insertion_point(field:grpc.testing.StreamingOutputCallRequest.response_parameters)
    pub response_parameters: ::std::vec::Vec<ResponseParameters>,
    // @@protoc_insertion_point(field:grpc.testing.StreamingOutputCallRequest.payload)
    pub payload: ::protobufv3::MessageField<Payload>,
    // @@protoc_insertion_point(field:grpc.testing.StreamingOutputCallRequest.response_status)
    pub response_status: ::protobufv3::MessageField<EchoStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.StreamingOutputCallRequest.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamingOutputCallRequest {
    fn default() -> &'a StreamingOutputCallRequest {
        <StreamingOutputCallRequest as ::protobufv3::Message>::default_instance()
    }
}

impl StreamingOutputCallRequest {
    pub fn new() -> StreamingOutputCallRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response_type",
            |m: &StreamingOutputCallRequest| { &m.response_type },
            |m: &mut StreamingOutputCallRequest| { &mut m.response_type },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "response_parameters",
            |m: &StreamingOutputCallRequest| { &m.response_parameters },
            |m: &mut StreamingOutputCallRequest| { &mut m.response_parameters },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, Payload>(
            "payload",
            |m: &StreamingOutputCallRequest| { &m.payload },
            |m: &mut StreamingOutputCallRequest| { &mut m.payload },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, EchoStatus>(
            "response_status",
            |m: &StreamingOutputCallRequest| { &m.response_status },
            |m: &mut StreamingOutputCallRequest| { &mut m.response_status },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<StreamingOutputCallRequest>(
            "StreamingOutputCallRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for StreamingOutputCallRequest {
    const NAME: &'static str = "StreamingOutputCallRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.response_parameters.push(is.read_message()?);
                },
                26 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.payload)?;
                },
                58 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.response_status)?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.response_type != ::protobufv3::EnumOrUnknown::new(PayloadType::COMPRESSABLE) {
            my_size += ::protobufv3::rt::int32_size(1, self.response_type.value());
        }
        for value in &self.response_parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.response_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.response_type != ::protobufv3::EnumOrUnknown::new(PayloadType::COMPRESSABLE) {
            os.write_enum(1, ::protobufv3::EnumOrUnknown::value(&self.response_type))?;
        }
        for v in &self.response_parameters {
            ::protobufv3::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.payload.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.response_status.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamingOutputCallRequest {
        StreamingOutputCallRequest::new()
    }

    fn clear(&mut self) {
        self.response_type = ::protobufv3::EnumOrUnknown::new(PayloadType::COMPRESSABLE);
        self.response_parameters.clear();
        self.payload.clear();
        self.response_status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamingOutputCallRequest {
        static instance: StreamingOutputCallRequest = StreamingOutputCallRequest {
            response_type: ::protobufv3::EnumOrUnknown::from_i32(0),
            response_parameters: ::std::vec::Vec::new(),
            payload: ::protobufv3::MessageField::none(),
            response_status: ::protobufv3::MessageField::none(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for StreamingOutputCallRequest {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamingOutputCallRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamingOutputCallRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for StreamingOutputCallRequest {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.StreamingOutputCallResponse)
pub struct StreamingOutputCallResponse {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.StreamingOutputCallResponse.payload)
    pub payload: ::protobufv3::MessageField<Payload>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.StreamingOutputCallResponse.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamingOutputCallResponse {
    fn default() -> &'a StreamingOutputCallResponse {
        <StreamingOutputCallResponse as ::protobufv3::Message>::default_instance()
    }
}

impl StreamingOutputCallResponse {
    pub fn new() -> StreamingOutputCallResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, Payload>(
            "payload",
            |m: &StreamingOutputCallResponse| { &m.payload },
            |m: &mut StreamingOutputCallResponse| { &mut m.payload },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<StreamingOutputCallResponse>(
            "StreamingOutputCallResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for StreamingOutputCallResponse {
    const NAME: &'static str = "StreamingOutputCallResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.payload)?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if let Some(v) = self.payload.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamingOutputCallResponse {
        StreamingOutputCallResponse::new()
    }

    fn clear(&mut self) {
        self.payload.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamingOutputCallResponse {
        static instance: StreamingOutputCallResponse = StreamingOutputCallResponse {
            payload: ::protobufv3::MessageField::none(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for StreamingOutputCallResponse {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamingOutputCallResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamingOutputCallResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for StreamingOutputCallResponse {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ReconnectParams)
pub struct ReconnectParams {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.ReconnectParams.max_reconnect_backoff_ms)
    pub max_reconnect_backoff_ms: i32,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ReconnectParams.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReconnectParams {
    fn default() -> &'a ReconnectParams {
        <ReconnectParams as ::protobufv3::Message>::default_instance()
    }
}

impl ReconnectParams {
    pub fn new() -> ReconnectParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_reconnect_backoff_ms",
            |m: &ReconnectParams| { &m.max_reconnect_backoff_ms },
            |m: &mut ReconnectParams| { &mut m.max_reconnect_backoff_ms },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ReconnectParams>(
            "ReconnectParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ReconnectParams {
    const NAME: &'static str = "ReconnectParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_reconnect_backoff_ms = is.read_int32()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.max_reconnect_backoff_ms != 0 {
            my_size += ::protobufv3::rt::int32_size(1, self.max_reconnect_backoff_ms);
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.max_reconnect_backoff_ms != 0 {
            os.write_int32(1, self.max_reconnect_backoff_ms)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReconnectParams {
        ReconnectParams::new()
    }

    fn clear(&mut self) {
        self.max_reconnect_backoff_ms = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReconnectParams {
        static instance: ReconnectParams = ReconnectParams {
            max_reconnect_backoff_ms: 0,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ReconnectParams {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReconnectParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReconnectParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ReconnectParams {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ReconnectInfo)
pub struct ReconnectInfo {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.ReconnectInfo.passed)
    pub passed: bool,
    // @@protoc_insertion_point(field:grpc.testing.ReconnectInfo.backoff_ms)
    pub backoff_ms: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ReconnectInfo.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReconnectInfo {
    fn default() -> &'a ReconnectInfo {
        <ReconnectInfo as ::protobufv3::Message>::default_instance()
    }
}

impl ReconnectInfo {
    pub fn new() -> ReconnectInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "passed",
            |m: &ReconnectInfo| { &m.passed },
            |m: &mut ReconnectInfo| { &mut m.passed },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "backoff_ms",
            |m: &ReconnectInfo| { &m.backoff_ms },
            |m: &mut ReconnectInfo| { &mut m.backoff_ms },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ReconnectInfo>(
            "ReconnectInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ReconnectInfo {
    const NAME: &'static str = "ReconnectInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.passed = is.read_bool()?;
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.backoff_ms)?;
                },
                16 => {
                    self.backoff_ms.push(is.read_int32()?);
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.passed != false {
            my_size += 1 + 1;
        }
        for value in &self.backoff_ms {
            my_size += ::protobufv3::rt::int32_size(2, *value);
        };
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.passed != false {
            os.write_bool(1, self.passed)?;
        }
        for v in &self.backoff_ms {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReconnectInfo {
        ReconnectInfo::new()
    }

    fn clear(&mut self) {
        self.passed = false;
        self.backoff_ms.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReconnectInfo {
        static instance: ReconnectInfo = ReconnectInfo {
            passed: false,
            backoff_ms: ::std::vec::Vec::new(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ReconnectInfo {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReconnectInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReconnectInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ReconnectInfo {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:grpc.testing.PayloadType)
pub enum PayloadType {
    // @@protoc_insertion_point(enum_value:grpc.testing.PayloadType.COMPRESSABLE)
    COMPRESSABLE = 0,
}

impl ::protobufv3::Enum for PayloadType {
    const NAME: &'static str = "PayloadType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PayloadType> {
        match value {
            0 => ::std::option::Option::Some(PayloadType::COMPRESSABLE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PayloadType] = &[
        PayloadType::COMPRESSABLE,
    ];
}

impl ::protobufv3::EnumFull for PayloadType {
    fn enum_descriptor() -> ::protobufv3::reflect::EnumDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::EnumDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PayloadType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobufv3::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PayloadType {
    fn default() -> Self {
        PayloadType::COMPRESSABLE
    }
}

impl PayloadType {
    fn generated_enum_descriptor_data() -> ::protobufv3::reflect::GeneratedEnumDescriptorData {
        ::protobufv3::reflect::GeneratedEnumDescriptorData::new::<PayloadType>("PayloadType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bgrpc/testing/messages.proto\x12\x0cgrpc.testing\"!\n\tBoolValue\
    \x12\x14\n\x05value\x18\x01\x20\x01(\x08R\x05value\"L\n\x07Payload\x12-\
    \n\x04type\x18\x01\x20\x01(\x0e2\x19.grpc.testing.PayloadTypeR\x04type\
    \x12\x12\n\x04body\x18\x02\x20\x01(\x0cR\x04body\":\n\nEchoStatus\x12\
    \x12\n\x04code\x18\x01\x20\x01(\x05R\x04code\x12\x18\n\x07message\x18\
    \x02\x20\x01(\tR\x07message\"\xc7\x03\n\rSimpleRequest\x12>\n\rresponse_\
    type\x18\x01\x20\x01(\x0e2\x19.grpc.testing.PayloadTypeR\x0cresponseType\
    \x12#\n\rresponse_size\x18\x02\x20\x01(\x05R\x0cresponseSize\x12/\n\x07p\
    ayload\x18\x03\x20\x01(\x0b2\x15.grpc.testing.PayloadR\x07payload\x12#\n\
    \rfill_username\x18\x04\x20\x01(\x08R\x0cfillUsername\x12(\n\x10fill_oau\
    th_scope\x18\x05\x20\x01(\x08R\x0efillOauthScope\x12H\n\x13response_comp\
    ressed\x18\x06\x20\x01(\x0b2\x17.grpc.testing.BoolValueR\x12responseComp\
    ressed\x12A\n\x0fresponse_status\x18\x07\x20\x01(\x0b2\x18.grpc.testing.\
    EchoStatusR\x0eresponseStatus\x12D\n\x11expect_compressed\x18\x08\x20\
    \x01(\x0b2\x17.grpc.testing.BoolValueR\x10expectCompressed\"~\n\x0eSimpl\
    eResponse\x12/\n\x07payload\x18\x01\x20\x01(\x0b2\x15.grpc.testing.Paylo\
    adR\x07payload\x12\x1a\n\x08username\x18\x02\x20\x01(\tR\x08username\x12\
    \x1f\n\x0boauth_scope\x18\x03\x20\x01(\tR\noauthScope\"\x92\x01\n\x19Str\
    eamingInputCallRequest\x12/\n\x07payload\x18\x01\x20\x01(\x0b2\x15.grpc.\
    testing.PayloadR\x07payload\x12D\n\x11expect_compressed\x18\x02\x20\x01(\
    \x0b2\x17.grpc.testing.BoolValueR\x10expectCompressed\"T\n\x1aStreamingI\
    nputCallResponse\x126\n\x17aggregated_payload_size\x18\x01\x20\x01(\x05R\
    \x15aggregatedPayloadSize\"\x82\x01\n\x12ResponseParameters\x12\x12\n\
    \x04size\x18\x01\x20\x01(\x05R\x04size\x12\x1f\n\x0binterval_us\x18\x02\
    \x20\x01(\x05R\nintervalUs\x127\n\ncompressed\x18\x03\x20\x01(\x0b2\x17.\
    grpc.testing.BoolValueR\ncompressed\"\xa3\x02\n\x1aStreamingOutputCallRe\
    quest\x12>\n\rresponse_type\x18\x01\x20\x01(\x0e2\x19.grpc.testing.Paylo\
    adTypeR\x0cresponseType\x12Q\n\x13response_parameters\x18\x02\x20\x03(\
    \x0b2\x20.grpc.testing.ResponseParametersR\x12responseParameters\x12/\n\
    \x07payload\x18\x03\x20\x01(\x0b2\x15.grpc.testing.PayloadR\x07payload\
    \x12A\n\x0fresponse_status\x18\x07\x20\x01(\x0b2\x18.grpc.testing.EchoSt\
    atusR\x0eresponseStatus\"N\n\x1bStreamingOutputCallResponse\x12/\n\x07pa\
    yload\x18\x01\x20\x01(\x0b2\x15.grpc.testing.PayloadR\x07payload\"J\n\
    \x0fReconnectParams\x127\n\x18max_reconnect_backoff_ms\x18\x01\x20\x01(\
    \x05R\x15maxReconnectBackoffMs\"F\n\rReconnectInfo\x12\x16\n\x06passed\
    \x18\x01\x20\x01(\x08R\x06passed\x12\x1d\n\nbackoff_ms\x18\x02\x20\x03(\
    \x05R\tbackoffMs*\x1f\n\x0bPayloadType\x12\x10\n\x0cCOMPRESSABLE\x10\0b\
    \x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobufv3::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobufv3::rt::Lazy<::protobufv3::descriptor::FileDescriptorProto> = ::protobufv3::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobufv3::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobufv3::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobufv3::rt::Lazy<::protobufv3::reflect::GeneratedFileDescriptor> = ::protobufv3::rt::Lazy::new();
    static file_descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::FileDescriptor> = ::protobufv3::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(BoolValue::generated_message_descriptor_data());
            messages.push(Payload::generated_message_descriptor_data());
            messages.push(EchoStatus::generated_message_descriptor_data());
            messages.push(SimpleRequest::generated_message_descriptor_data());
            messages.push(SimpleResponse::generated_message_descriptor_data());
            messages.push(StreamingInputCallRequest::generated_message_descriptor_data());
            messages.push(StreamingInputCallResponse::generated_message_descriptor_data());
            messages.push(ResponseParameters::generated_message_descriptor_data());
            messages.push(StreamingOutputCallRequest::generated_message_descriptor_data());
            messages.push(StreamingOutputCallResponse::generated_message_descriptor_data());
            messages.push(ReconnectParams::generated_message_descriptor_data());
            messages.push(ReconnectInfo::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(PayloadType::generated_enum_descriptor_data());
            ::protobufv3::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobufv3::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
