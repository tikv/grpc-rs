// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `benchmark_service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17benchmark_service.proto\x12\x0cgrpc.testing\x1a\x0emessages.proto2\
    \xf2\x03\n\x10BenchmarkService\x12F\n\tUnaryCall\x12\x1b.grpc.testing.Si\
    mpleRequest\x1a\x1c.grpc.testing.SimpleResponse\x12N\n\rStreamingCall\
    \x12\x1b.grpc.testing.SimpleRequest\x1a\x1c.grpc.testing.SimpleResponse(\
    \x010\x01\x12R\n\x13StreamingFromClient\x12\x1b.grpc.testing.SimpleReque\
    st\x1a\x1c.grpc.testing.SimpleResponse(\x01\x12R\n\x13StreamingFromServe\
    r\x12\x1b.grpc.testing.SimpleRequest\x1a\x1c.grpc.testing.SimpleResponse\
    0\x01\x12R\n\x11StreamingBothWays\x12\x1b.grpc.testing.SimpleRequest\x1a\
    \x1c.grpc.testing.SimpleResponse(\x010\x01\x12J\n\x11GetBeforeSnapshot\
    \x12\x1b.grpc.testing.SimpleRequest\x1a\x18.grpc.testing.MemorySizeJ\xb5\
    \x0e\n\x06\x12\x04\x10\0.\x01\n\xb8\x05\n\x01\x0c\x12\x03\x10\0\x12\x1aw\
    \x20An\x20integration\x20test\x20service\x20that\x20covers\x20all\x20the\
    \x20method\x20signature\x20permutations\n\x20of\x20unary/streaming\x20re\
    quests/responses.\n2\xb4\x04\x20Copyright\x202015\x20gRPC\x20authors.\n\
    \n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\
    \x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\
    \x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20ma\
    y\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\
    \x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20requ\
    ired\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\
    \x20software\n\x20distributed\x20under\x20the\x20License\x20is\x20distri\
    buted\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\
    \x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\
    \x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20lan\
    guage\x20governing\x20permissions\x20and\n\x20limitations\x20under\x20th\
    e\x20License.\n\n\t\n\x02\x03\0\x12\x03\x12\0\x18\n\x08\n\x01\x02\x12\
    \x03\x14\0\x15\n\n\n\x02\x06\0\x12\x04\x16\0.\x01\n\n\n\x03\x06\0\x01\
    \x12\x03\x16\x08\x18\nb\n\x04\x06\0\x02\0\x12\x03\x19\x028\x1aU\x20One\
    \x20request\x20followed\x20by\x20one\x20response.\n\x20The\x20server\x20\
    returns\x20the\x20client\x20payload\x20as-is.\n\n\x0c\n\x05\x06\0\x02\0\
    \x01\x12\x03\x19\x06\x0f\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x19\x10\x1d\
    \n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x19(6\n\xae\x01\n\x04\x06\0\x02\x01\
    \x12\x03\x1e\x02J\x1a\xa0\x01\x20Repeated\x20sequence\x20of\x20one\x20re\
    quest\x20followed\x20by\x20one\x20response.\n\x20Should\x20be\x20called\
    \x20streaming\x20ping-pong\n\x20The\x20server\x20returns\x20the\x20clien\
    t\x20payload\x20as-is\x20on\x20each\x20response\n\n\x0c\n\x05\x06\0\x02\
    \x01\x01\x12\x03\x1e\x06\x13\n\x0c\n\x05\x06\0\x02\x01\x05\x12\x03\x1e\
    \x14\x1a\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x1e\x1b(\n\x0c\n\x05\x06\
    \0\x02\x01\x06\x12\x03\x1e39\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x1e:H\
    \n\x93\x01\n\x04\x06\0\x02\x02\x12\x03\"\x02I\x1a\x85\x01\x20Single-side\
    d\x20unbounded\x20streaming\x20from\x20client\x20to\x20server\n\x20The\
    \x20server\x20returns\x20the\x20client\x20payload\x20as-is\x20once\x20th\
    e\x20client\x20does\x20WritesDone\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\
    \x03\"\x06\x19\n\x0c\n\x05\x06\0\x02\x02\x05\x12\x03\"\x1a\x20\n\x0c\n\
    \x05\x06\0\x02\x02\x02\x12\x03\"!.\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\
    \"9G\n}\n\x04\x06\0\x02\x03\x12\x03&\x02I\x1ap\x20Single-sided\x20unboun\
    ded\x20streaming\x20from\x20server\x20to\x20client\n\x20The\x20server\
    \x20repeatedly\x20returns\x20the\x20client\x20payload\x20as-is\n\n\x0c\n\
    \x05\x06\0\x02\x03\x01\x12\x03&\x06\x19\n\x0c\n\x05\x06\0\x02\x03\x02\
    \x12\x03&\x1a'\n\x0c\n\x05\x06\0\x02\x03\x06\x12\x03&28\n\x0c\n\x05\x06\
    \0\x02\x03\x03\x12\x03&9G\n\x83\x01\n\x04\x06\0\x02\x04\x12\x03*\x02N\
    \x1av\x20Two-sided\x20unbounded\x20streaming\x20between\x20server\x20to\
    \x20client\n\x20Both\x20sides\x20send\x20the\x20content\x20of\x20their\
    \x20own\x20choice\x20to\x20the\x20other\n\n\x0c\n\x05\x06\0\x02\x04\x01\
    \x12\x03*\x06\x17\n\x0c\n\x05\x06\0\x02\x04\x05\x12\x03*\x18\x1e\n\x0c\n\
    \x05\x06\0\x02\x04\x02\x12\x03*\x1f,\n\x0c\n\x05\x06\0\x02\x04\x06\x12\
    \x03*7=\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03*>L\nC\n\x04\x06\0\x02\x05\
    \x12\x03-\x02<\x1a6Get\x20the\x20memory\x20usage\x20of\x20process\x20bef\
    ore\x20server\x20is\x20made\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03-\x06\
    \x17\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03-\x18%\n\x0c\n\x05\x06\0\x02\
    \x05\x03\x12\x03-0:b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::messages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(0);
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
