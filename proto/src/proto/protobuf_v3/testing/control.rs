// This file is generated by rust-protobuf 3.2.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `grpc/testing/control.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobufv3::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.PoissonParams)
pub struct PoissonParams {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.PoissonParams.offered_load)
    pub offered_load: f64,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.PoissonParams.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoissonParams {
    fn default() -> &'a PoissonParams {
        <PoissonParams as ::protobufv3::Message>::default_instance()
    }
}

impl PoissonParams {
    pub fn new() -> PoissonParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offered_load",
            |m: &PoissonParams| { &m.offered_load },
            |m: &mut PoissonParams| { &mut m.offered_load },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<PoissonParams>(
            "PoissonParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for PoissonParams {
    const NAME: &'static str = "PoissonParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.offered_load = is.read_double()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.offered_load != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.offered_load != 0. {
            os.write_double(1, self.offered_load)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoissonParams {
        PoissonParams::new()
    }

    fn clear(&mut self) {
        self.offered_load = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoissonParams {
        static instance: PoissonParams = PoissonParams {
            offered_load: 0.,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for PoissonParams {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoissonParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoissonParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for PoissonParams {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ClosedLoopParams)
pub struct ClosedLoopParams {
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ClosedLoopParams.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClosedLoopParams {
    fn default() -> &'a ClosedLoopParams {
        <ClosedLoopParams as ::protobufv3::Message>::default_instance()
    }
}

impl ClosedLoopParams {
    pub fn new() -> ClosedLoopParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ClosedLoopParams>(
            "ClosedLoopParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ClosedLoopParams {
    const NAME: &'static str = "ClosedLoopParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClosedLoopParams {
        ClosedLoopParams::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClosedLoopParams {
        static instance: ClosedLoopParams = ClosedLoopParams {
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ClosedLoopParams {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClosedLoopParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClosedLoopParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ClosedLoopParams {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.LoadParams)
pub struct LoadParams {
    // message oneof groups
    pub load: ::std::option::Option<load_params::Load>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.LoadParams.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadParams {
    fn default() -> &'a LoadParams {
        <LoadParams as ::protobufv3::Message>::default_instance()
    }
}

impl LoadParams {
    pub fn new() -> LoadParams {
        ::std::default::Default::default()
    }

    // .grpc.testing.ClosedLoopParams closed_loop = 1;

    pub fn closed_loop(&self) -> &ClosedLoopParams {
        match self.load {
            ::std::option::Option::Some(load_params::Load::ClosedLoop(ref v)) => v,
            _ => <ClosedLoopParams as ::protobufv3::Message>::default_instance(),
        }
    }

    pub fn clear_closed_loop(&mut self) {
        self.load = ::std::option::Option::None;
    }

    pub fn has_closed_loop(&self) -> bool {
        match self.load {
            ::std::option::Option::Some(load_params::Load::ClosedLoop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_closed_loop(&mut self, v: ClosedLoopParams) {
        self.load = ::std::option::Option::Some(load_params::Load::ClosedLoop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_closed_loop(&mut self) -> &mut ClosedLoopParams {
        if let ::std::option::Option::Some(load_params::Load::ClosedLoop(_)) = self.load {
        } else {
            self.load = ::std::option::Option::Some(load_params::Load::ClosedLoop(ClosedLoopParams::new()));
        }
        match self.load {
            ::std::option::Option::Some(load_params::Load::ClosedLoop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_closed_loop(&mut self) -> ClosedLoopParams {
        if self.has_closed_loop() {
            match self.load.take() {
                ::std::option::Option::Some(load_params::Load::ClosedLoop(v)) => v,
                _ => panic!(),
            }
        } else {
            ClosedLoopParams::new()
        }
    }

    // .grpc.testing.PoissonParams poisson = 2;

    pub fn poisson(&self) -> &PoissonParams {
        match self.load {
            ::std::option::Option::Some(load_params::Load::Poisson(ref v)) => v,
            _ => <PoissonParams as ::protobufv3::Message>::default_instance(),
        }
    }

    pub fn clear_poisson(&mut self) {
        self.load = ::std::option::Option::None;
    }

    pub fn has_poisson(&self) -> bool {
        match self.load {
            ::std::option::Option::Some(load_params::Load::Poisson(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_poisson(&mut self, v: PoissonParams) {
        self.load = ::std::option::Option::Some(load_params::Load::Poisson(v))
    }

    // Mutable pointer to the field.
    pub fn mut_poisson(&mut self) -> &mut PoissonParams {
        if let ::std::option::Option::Some(load_params::Load::Poisson(_)) = self.load {
        } else {
            self.load = ::std::option::Option::Some(load_params::Load::Poisson(PoissonParams::new()));
        }
        match self.load {
            ::std::option::Option::Some(load_params::Load::Poisson(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_poisson(&mut self) -> PoissonParams {
        if self.has_poisson() {
            match self.load.take() {
                ::std::option::Option::Some(load_params::Load::Poisson(v)) => v,
                _ => panic!(),
            }
        } else {
            PoissonParams::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobufv3::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ClosedLoopParams>(
            "closed_loop",
            LoadParams::has_closed_loop,
            LoadParams::closed_loop,
            LoadParams::mut_closed_loop,
            LoadParams::set_closed_loop,
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PoissonParams>(
            "poisson",
            LoadParams::has_poisson,
            LoadParams::poisson,
            LoadParams::mut_poisson,
            LoadParams::set_poisson,
        ));
        oneofs.push(load_params::Load::generated_oneof_descriptor_data());
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<LoadParams>(
            "LoadParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for LoadParams {
    const NAME: &'static str = "LoadParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.load = ::std::option::Option::Some(load_params::Load::ClosedLoop(is.read_message()?));
                },
                18 => {
                    self.load = ::std::option::Option::Some(load_params::Load::Poisson(is.read_message()?));
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.load {
            match v {
                &load_params::Load::ClosedLoop(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
                },
                &load_params::Load::Poisson(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.load {
            match v {
                &load_params::Load::ClosedLoop(ref v) => {
                    ::protobufv3::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &load_params::Load::Poisson(ref v) => {
                    ::protobufv3::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadParams {
        LoadParams::new()
    }

    fn clear(&mut self) {
        self.load = ::std::option::Option::None;
        self.load = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadParams {
        static instance: LoadParams = LoadParams {
            load: ::std::option::Option::None,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for LoadParams {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for LoadParams {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LoadParams`
pub mod load_params {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:grpc.testing.LoadParams.load)
    pub enum Load {
        // @@protoc_insertion_point(oneof_field:grpc.testing.LoadParams.closed_loop)
        ClosedLoop(super::ClosedLoopParams),
        // @@protoc_insertion_point(oneof_field:grpc.testing.LoadParams.poisson)
        Poisson(super::PoissonParams),
    }

    impl ::protobufv3::Oneof for Load {
    }

    impl ::protobufv3::OneofFull for Load {
        fn descriptor() -> ::protobufv3::reflect::OneofDescriptor {
            static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::OneofDescriptor> = ::protobufv3::rt::Lazy::new();
            descriptor.get(|| <super::LoadParams as ::protobufv3::MessageFull>::descriptor().oneof_by_name("load").unwrap()).clone()
        }
    }

    impl Load {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobufv3::reflect::GeneratedOneofDescriptorData {
            ::protobufv3::reflect::GeneratedOneofDescriptorData::new::<Load>("load")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.SecurityParams)
pub struct SecurityParams {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.SecurityParams.use_test_ca)
    pub use_test_ca: bool,
    // @@protoc_insertion_point(field:grpc.testing.SecurityParams.server_host_override)
    pub server_host_override: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.testing.SecurityParams.cred_type)
    pub cred_type: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.SecurityParams.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecurityParams {
    fn default() -> &'a SecurityParams {
        <SecurityParams as ::protobufv3::Message>::default_instance()
    }
}

impl SecurityParams {
    pub fn new() -> SecurityParams {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "use_test_ca",
            |m: &SecurityParams| { &m.use_test_ca },
            |m: &mut SecurityParams| { &mut m.use_test_ca },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_host_override",
            |m: &SecurityParams| { &m.server_host_override },
            |m: &mut SecurityParams| { &mut m.server_host_override },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cred_type",
            |m: &SecurityParams| { &m.cred_type },
            |m: &mut SecurityParams| { &mut m.cred_type },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<SecurityParams>(
            "SecurityParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for SecurityParams {
    const NAME: &'static str = "SecurityParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.use_test_ca = is.read_bool()?;
                },
                18 => {
                    self.server_host_override = is.read_string()?;
                },
                26 => {
                    self.cred_type = is.read_string()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.use_test_ca != false {
            my_size += 1 + 1;
        }
        if !self.server_host_override.is_empty() {
            my_size += ::protobufv3::rt::string_size(2, &self.server_host_override);
        }
        if !self.cred_type.is_empty() {
            my_size += ::protobufv3::rt::string_size(3, &self.cred_type);
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.use_test_ca != false {
            os.write_bool(1, self.use_test_ca)?;
        }
        if !self.server_host_override.is_empty() {
            os.write_string(2, &self.server_host_override)?;
        }
        if !self.cred_type.is_empty() {
            os.write_string(3, &self.cred_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecurityParams {
        SecurityParams::new()
    }

    fn clear(&mut self) {
        self.use_test_ca = false;
        self.server_host_override.clear();
        self.cred_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecurityParams {
        static instance: SecurityParams = SecurityParams {
            use_test_ca: false,
            server_host_override: ::std::string::String::new(),
            cred_type: ::std::string::String::new(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for SecurityParams {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecurityParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecurityParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for SecurityParams {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ChannelArg)
pub struct ChannelArg {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.ChannelArg.name)
    pub name: ::std::string::String,
    // message oneof groups
    pub value: ::std::option::Option<channel_arg::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ChannelArg.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChannelArg {
    fn default() -> &'a ChannelArg {
        <ChannelArg as ::protobufv3::Message>::default_instance()
    }
}

impl ChannelArg {
    pub fn new() -> ChannelArg {
        ::std::default::Default::default()
    }

    // string str_value = 2;

    pub fn str_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(channel_arg::Value::StrValue(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_str_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_str_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(channel_arg::Value::StrValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_str_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(channel_arg::Value::StrValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_str_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(channel_arg::Value::StrValue(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(channel_arg::Value::StrValue(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(channel_arg::Value::StrValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_str_value(&mut self) -> ::std::string::String {
        if self.has_str_value() {
            match self.value.take() {
                ::std::option::Option::Some(channel_arg::Value::StrValue(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // int32 int_value = 3;

    pub fn int_value(&self) -> i32 {
        match self.value {
            ::std::option::Option::Some(channel_arg::Value::IntValue(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(channel_arg::Value::IntValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(channel_arg::Value::IntValue(v))
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ChannelArg| { &m.name },
            |m: &mut ChannelArg| { &mut m.name },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "str_value",
            ChannelArg::has_str_value,
            ChannelArg::str_value,
            ChannelArg::set_str_value,
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "int_value",
            ChannelArg::has_int_value,
            ChannelArg::int_value,
            ChannelArg::set_int_value,
        ));
        oneofs.push(channel_arg::Value::generated_oneof_descriptor_data());
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ChannelArg>(
            "ChannelArg",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ChannelArg {
    const NAME: &'static str = "ChannelArg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.value = ::std::option::Option::Some(channel_arg::Value::StrValue(is.read_string()?));
                },
                24 => {
                    self.value = ::std::option::Option::Some(channel_arg::Value::IntValue(is.read_int32()?));
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobufv3::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &channel_arg::Value::StrValue(ref v) => {
                    my_size += ::protobufv3::rt::string_size(2, &v);
                },
                &channel_arg::Value::IntValue(v) => {
                    my_size += ::protobufv3::rt::int32_size(3, v);
                },
            };
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &channel_arg::Value::StrValue(ref v) => {
                    os.write_string(2, v)?;
                },
                &channel_arg::Value::IntValue(v) => {
                    os.write_int32(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChannelArg {
        ChannelArg::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChannelArg {
        static instance: ChannelArg = ChannelArg {
            name: ::std::string::String::new(),
            value: ::std::option::Option::None,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ChannelArg {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChannelArg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChannelArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ChannelArg {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ChannelArg`
pub mod channel_arg {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:grpc.testing.ChannelArg.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:grpc.testing.ChannelArg.str_value)
        StrValue(::std::string::String),
        // @@protoc_insertion_point(oneof_field:grpc.testing.ChannelArg.int_value)
        IntValue(i32),
    }

    impl ::protobufv3::Oneof for Value {
    }

    impl ::protobufv3::OneofFull for Value {
        fn descriptor() -> ::protobufv3::reflect::OneofDescriptor {
            static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::OneofDescriptor> = ::protobufv3::rt::Lazy::new();
            descriptor.get(|| <super::ChannelArg as ::protobufv3::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobufv3::reflect::GeneratedOneofDescriptorData {
            ::protobufv3::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ClientConfig)
pub struct ClientConfig {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.server_targets)
    pub server_targets: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.client_type)
    pub client_type: ::protobufv3::EnumOrUnknown<ClientType>,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.security_params)
    pub security_params: ::protobufv3::MessageField<SecurityParams>,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.outstanding_rpcs_per_channel)
    pub outstanding_rpcs_per_channel: i32,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.client_channels)
    pub client_channels: i32,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.async_client_threads)
    pub async_client_threads: i32,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.rpc_type)
    pub rpc_type: ::protobufv3::EnumOrUnknown<RpcType>,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.load_params)
    pub load_params: ::protobufv3::MessageField<LoadParams>,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.payload_config)
    pub payload_config: ::protobufv3::MessageField<super::payloads::PayloadConfig>,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.histogram_params)
    pub histogram_params: ::protobufv3::MessageField<super::stats::HistogramParams>,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.core_list)
    pub core_list: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.core_limit)
    pub core_limit: i32,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.other_client_api)
    pub other_client_api: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.channel_args)
    pub channel_args: ::std::vec::Vec<ChannelArg>,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.threads_per_cq)
    pub threads_per_cq: i32,
    // @@protoc_insertion_point(field:grpc.testing.ClientConfig.messages_per_stream)
    pub messages_per_stream: i32,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ClientConfig.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientConfig {
    fn default() -> &'a ClientConfig {
        <ClientConfig as ::protobufv3::Message>::default_instance()
    }
}

impl ClientConfig {
    pub fn new() -> ClientConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "server_targets",
            |m: &ClientConfig| { &m.server_targets },
            |m: &mut ClientConfig| { &mut m.server_targets },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_type",
            |m: &ClientConfig| { &m.client_type },
            |m: &mut ClientConfig| { &mut m.client_type },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, SecurityParams>(
            "security_params",
            |m: &ClientConfig| { &m.security_params },
            |m: &mut ClientConfig| { &mut m.security_params },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "outstanding_rpcs_per_channel",
            |m: &ClientConfig| { &m.outstanding_rpcs_per_channel },
            |m: &mut ClientConfig| { &mut m.outstanding_rpcs_per_channel },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_channels",
            |m: &ClientConfig| { &m.client_channels },
            |m: &mut ClientConfig| { &mut m.client_channels },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "async_client_threads",
            |m: &ClientConfig| { &m.async_client_threads },
            |m: &mut ClientConfig| { &mut m.async_client_threads },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rpc_type",
            |m: &ClientConfig| { &m.rpc_type },
            |m: &mut ClientConfig| { &mut m.rpc_type },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, LoadParams>(
            "load_params",
            |m: &ClientConfig| { &m.load_params },
            |m: &mut ClientConfig| { &mut m.load_params },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, super::payloads::PayloadConfig>(
            "payload_config",
            |m: &ClientConfig| { &m.payload_config },
            |m: &mut ClientConfig| { &mut m.payload_config },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, super::stats::HistogramParams>(
            "histogram_params",
            |m: &ClientConfig| { &m.histogram_params },
            |m: &mut ClientConfig| { &mut m.histogram_params },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "core_list",
            |m: &ClientConfig| { &m.core_list },
            |m: &mut ClientConfig| { &mut m.core_list },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "core_limit",
            |m: &ClientConfig| { &m.core_limit },
            |m: &mut ClientConfig| { &mut m.core_limit },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "other_client_api",
            |m: &ClientConfig| { &m.other_client_api },
            |m: &mut ClientConfig| { &mut m.other_client_api },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channel_args",
            |m: &ClientConfig| { &m.channel_args },
            |m: &mut ClientConfig| { &mut m.channel_args },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "threads_per_cq",
            |m: &ClientConfig| { &m.threads_per_cq },
            |m: &mut ClientConfig| { &mut m.threads_per_cq },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "messages_per_stream",
            |m: &ClientConfig| { &m.messages_per_stream },
            |m: &mut ClientConfig| { &mut m.messages_per_stream },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ClientConfig>(
            "ClientConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ClientConfig {
    const NAME: &'static str = "ClientConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.server_targets.push(is.read_string()?);
                },
                16 => {
                    self.client_type = is.read_enum_or_unknown()?;
                },
                26 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.security_params)?;
                },
                32 => {
                    self.outstanding_rpcs_per_channel = is.read_int32()?;
                },
                40 => {
                    self.client_channels = is.read_int32()?;
                },
                56 => {
                    self.async_client_threads = is.read_int32()?;
                },
                64 => {
                    self.rpc_type = is.read_enum_or_unknown()?;
                },
                82 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.load_params)?;
                },
                90 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.payload_config)?;
                },
                98 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.histogram_params)?;
                },
                106 => {
                    is.read_repeated_packed_int32_into(&mut self.core_list)?;
                },
                104 => {
                    self.core_list.push(is.read_int32()?);
                },
                112 => {
                    self.core_limit = is.read_int32()?;
                },
                122 => {
                    self.other_client_api = is.read_string()?;
                },
                130 => {
                    self.channel_args.push(is.read_message()?);
                },
                136 => {
                    self.threads_per_cq = is.read_int32()?;
                },
                144 => {
                    self.messages_per_stream = is.read_int32()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.server_targets {
            my_size += ::protobufv3::rt::string_size(1, &value);
        };
        if self.client_type != ::protobufv3::EnumOrUnknown::new(ClientType::SYNC_CLIENT) {
            my_size += ::protobufv3::rt::int32_size(2, self.client_type.value());
        }
        if let Some(v) = self.security_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if self.outstanding_rpcs_per_channel != 0 {
            my_size += ::protobufv3::rt::int32_size(4, self.outstanding_rpcs_per_channel);
        }
        if self.client_channels != 0 {
            my_size += ::protobufv3::rt::int32_size(5, self.client_channels);
        }
        if self.async_client_threads != 0 {
            my_size += ::protobufv3::rt::int32_size(7, self.async_client_threads);
        }
        if self.rpc_type != ::protobufv3::EnumOrUnknown::new(RpcType::UNARY) {
            my_size += ::protobufv3::rt::int32_size(8, self.rpc_type.value());
        }
        if let Some(v) = self.load_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.payload_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.histogram_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.core_list {
            my_size += ::protobufv3::rt::int32_size(13, *value);
        };
        if self.core_limit != 0 {
            my_size += ::protobufv3::rt::int32_size(14, self.core_limit);
        }
        if !self.other_client_api.is_empty() {
            my_size += ::protobufv3::rt::string_size(15, &self.other_client_api);
        }
        for value in &self.channel_args {
            let len = value.compute_size();
            my_size += 2 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        };
        if self.threads_per_cq != 0 {
            my_size += ::protobufv3::rt::int32_size(17, self.threads_per_cq);
        }
        if self.messages_per_stream != 0 {
            my_size += ::protobufv3::rt::int32_size(18, self.messages_per_stream);
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        for v in &self.server_targets {
            os.write_string(1, &v)?;
        };
        if self.client_type != ::protobufv3::EnumOrUnknown::new(ClientType::SYNC_CLIENT) {
            os.write_enum(2, ::protobufv3::EnumOrUnknown::value(&self.client_type))?;
        }
        if let Some(v) = self.security_params.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.outstanding_rpcs_per_channel != 0 {
            os.write_int32(4, self.outstanding_rpcs_per_channel)?;
        }
        if self.client_channels != 0 {
            os.write_int32(5, self.client_channels)?;
        }
        if self.async_client_threads != 0 {
            os.write_int32(7, self.async_client_threads)?;
        }
        if self.rpc_type != ::protobufv3::EnumOrUnknown::new(RpcType::UNARY) {
            os.write_enum(8, ::protobufv3::EnumOrUnknown::value(&self.rpc_type))?;
        }
        if let Some(v) = self.load_params.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.payload_config.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.histogram_params.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.core_list {
            os.write_int32(13, *v)?;
        };
        if self.core_limit != 0 {
            os.write_int32(14, self.core_limit)?;
        }
        if !self.other_client_api.is_empty() {
            os.write_string(15, &self.other_client_api)?;
        }
        for v in &self.channel_args {
            ::protobufv3::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        if self.threads_per_cq != 0 {
            os.write_int32(17, self.threads_per_cq)?;
        }
        if self.messages_per_stream != 0 {
            os.write_int32(18, self.messages_per_stream)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientConfig {
        ClientConfig::new()
    }

    fn clear(&mut self) {
        self.server_targets.clear();
        self.client_type = ::protobufv3::EnumOrUnknown::new(ClientType::SYNC_CLIENT);
        self.security_params.clear();
        self.outstanding_rpcs_per_channel = 0;
        self.client_channels = 0;
        self.async_client_threads = 0;
        self.rpc_type = ::protobufv3::EnumOrUnknown::new(RpcType::UNARY);
        self.load_params.clear();
        self.payload_config.clear();
        self.histogram_params.clear();
        self.core_list.clear();
        self.core_limit = 0;
        self.other_client_api.clear();
        self.channel_args.clear();
        self.threads_per_cq = 0;
        self.messages_per_stream = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientConfig {
        static instance: ClientConfig = ClientConfig {
            server_targets: ::std::vec::Vec::new(),
            client_type: ::protobufv3::EnumOrUnknown::from_i32(0),
            security_params: ::protobufv3::MessageField::none(),
            outstanding_rpcs_per_channel: 0,
            client_channels: 0,
            async_client_threads: 0,
            rpc_type: ::protobufv3::EnumOrUnknown::from_i32(0),
            load_params: ::protobufv3::MessageField::none(),
            payload_config: ::protobufv3::MessageField::none(),
            histogram_params: ::protobufv3::MessageField::none(),
            core_list: ::std::vec::Vec::new(),
            core_limit: 0,
            other_client_api: ::std::string::String::new(),
            channel_args: ::std::vec::Vec::new(),
            threads_per_cq: 0,
            messages_per_stream: 0,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ClientConfig {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ClientConfig {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ClientStatus)
pub struct ClientStatus {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.ClientStatus.stats)
    pub stats: ::protobufv3::MessageField<super::stats::ClientStats>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ClientStatus.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientStatus {
    fn default() -> &'a ClientStatus {
        <ClientStatus as ::protobufv3::Message>::default_instance()
    }
}

impl ClientStatus {
    pub fn new() -> ClientStatus {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, super::stats::ClientStats>(
            "stats",
            |m: &ClientStatus| { &m.stats },
            |m: &mut ClientStatus| { &mut m.stats },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ClientStatus>(
            "ClientStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ClientStatus {
    const NAME: &'static str = "ClientStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if let Some(v) = self.stats.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientStatus {
        ClientStatus::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientStatus {
        static instance: ClientStatus = ClientStatus {
            stats: ::protobufv3::MessageField::none(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ClientStatus {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ClientStatus {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.Mark)
pub struct Mark {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.Mark.reset)
    pub reset: bool,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.Mark.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Mark {
    fn default() -> &'a Mark {
        <Mark as ::protobufv3::Message>::default_instance()
    }
}

impl Mark {
    pub fn new() -> Mark {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reset",
            |m: &Mark| { &m.reset },
            |m: &mut Mark| { &mut m.reset },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<Mark>(
            "Mark",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for Mark {
    const NAME: &'static str = "Mark";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reset = is.read_bool()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.reset != false {
            my_size += 1 + 1;
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.reset != false {
            os.write_bool(1, self.reset)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Mark {
        Mark::new()
    }

    fn clear(&mut self) {
        self.reset = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Mark {
        static instance: Mark = Mark {
            reset: false,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for Mark {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Mark").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Mark {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for Mark {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ClientArgs)
pub struct ClientArgs {
    // message oneof groups
    pub argtype: ::std::option::Option<client_args::Argtype>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ClientArgs.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientArgs {
    fn default() -> &'a ClientArgs {
        <ClientArgs as ::protobufv3::Message>::default_instance()
    }
}

impl ClientArgs {
    pub fn new() -> ClientArgs {
        ::std::default::Default::default()
    }

    // .grpc.testing.ClientConfig setup = 1;

    pub fn setup(&self) -> &ClientConfig {
        match self.argtype {
            ::std::option::Option::Some(client_args::Argtype::Setup(ref v)) => v,
            _ => <ClientConfig as ::protobufv3::Message>::default_instance(),
        }
    }

    pub fn clear_setup(&mut self) {
        self.argtype = ::std::option::Option::None;
    }

    pub fn has_setup(&self) -> bool {
        match self.argtype {
            ::std::option::Option::Some(client_args::Argtype::Setup(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setup(&mut self, v: ClientConfig) {
        self.argtype = ::std::option::Option::Some(client_args::Argtype::Setup(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setup(&mut self) -> &mut ClientConfig {
        if let ::std::option::Option::Some(client_args::Argtype::Setup(_)) = self.argtype {
        } else {
            self.argtype = ::std::option::Option::Some(client_args::Argtype::Setup(ClientConfig::new()));
        }
        match self.argtype {
            ::std::option::Option::Some(client_args::Argtype::Setup(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setup(&mut self) -> ClientConfig {
        if self.has_setup() {
            match self.argtype.take() {
                ::std::option::Option::Some(client_args::Argtype::Setup(v)) => v,
                _ => panic!(),
            }
        } else {
            ClientConfig::new()
        }
    }

    // .grpc.testing.Mark mark = 2;

    pub fn mark(&self) -> &Mark {
        match self.argtype {
            ::std::option::Option::Some(client_args::Argtype::Mark(ref v)) => v,
            _ => <Mark as ::protobufv3::Message>::default_instance(),
        }
    }

    pub fn clear_mark(&mut self) {
        self.argtype = ::std::option::Option::None;
    }

    pub fn has_mark(&self) -> bool {
        match self.argtype {
            ::std::option::Option::Some(client_args::Argtype::Mark(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mark(&mut self, v: Mark) {
        self.argtype = ::std::option::Option::Some(client_args::Argtype::Mark(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mark(&mut self) -> &mut Mark {
        if let ::std::option::Option::Some(client_args::Argtype::Mark(_)) = self.argtype {
        } else {
            self.argtype = ::std::option::Option::Some(client_args::Argtype::Mark(Mark::new()));
        }
        match self.argtype {
            ::std::option::Option::Some(client_args::Argtype::Mark(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mark(&mut self) -> Mark {
        if self.has_mark() {
            match self.argtype.take() {
                ::std::option::Option::Some(client_args::Argtype::Mark(v)) => v,
                _ => panic!(),
            }
        } else {
            Mark::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobufv3::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ClientConfig>(
            "setup",
            ClientArgs::has_setup,
            ClientArgs::setup,
            ClientArgs::mut_setup,
            ClientArgs::set_setup,
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Mark>(
            "mark",
            ClientArgs::has_mark,
            ClientArgs::mark,
            ClientArgs::mut_mark,
            ClientArgs::set_mark,
        ));
        oneofs.push(client_args::Argtype::generated_oneof_descriptor_data());
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ClientArgs>(
            "ClientArgs",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ClientArgs {
    const NAME: &'static str = "ClientArgs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.argtype = ::std::option::Option::Some(client_args::Argtype::Setup(is.read_message()?));
                },
                18 => {
                    self.argtype = ::std::option::Option::Some(client_args::Argtype::Mark(is.read_message()?));
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.argtype {
            match v {
                &client_args::Argtype::Setup(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
                },
                &client_args::Argtype::Mark(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.argtype {
            match v {
                &client_args::Argtype::Setup(ref v) => {
                    ::protobufv3::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &client_args::Argtype::Mark(ref v) => {
                    ::protobufv3::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientArgs {
        ClientArgs::new()
    }

    fn clear(&mut self) {
        self.argtype = ::std::option::Option::None;
        self.argtype = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientArgs {
        static instance: ClientArgs = ClientArgs {
            argtype: ::std::option::Option::None,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ClientArgs {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientArgs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientArgs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ClientArgs {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ClientArgs`
pub mod client_args {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:grpc.testing.ClientArgs.argtype)
    pub enum Argtype {
        // @@protoc_insertion_point(oneof_field:grpc.testing.ClientArgs.setup)
        Setup(super::ClientConfig),
        // @@protoc_insertion_point(oneof_field:grpc.testing.ClientArgs.mark)
        Mark(super::Mark),
    }

    impl ::protobufv3::Oneof for Argtype {
    }

    impl ::protobufv3::OneofFull for Argtype {
        fn descriptor() -> ::protobufv3::reflect::OneofDescriptor {
            static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::OneofDescriptor> = ::protobufv3::rt::Lazy::new();
            descriptor.get(|| <super::ClientArgs as ::protobufv3::MessageFull>::descriptor().oneof_by_name("argtype").unwrap()).clone()
        }
    }

    impl Argtype {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobufv3::reflect::GeneratedOneofDescriptorData {
            ::protobufv3::reflect::GeneratedOneofDescriptorData::new::<Argtype>("argtype")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ServerConfig)
pub struct ServerConfig {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.ServerConfig.server_type)
    pub server_type: ::protobufv3::EnumOrUnknown<ServerType>,
    // @@protoc_insertion_point(field:grpc.testing.ServerConfig.security_params)
    pub security_params: ::protobufv3::MessageField<SecurityParams>,
    // @@protoc_insertion_point(field:grpc.testing.ServerConfig.port)
    pub port: i32,
    // @@protoc_insertion_point(field:grpc.testing.ServerConfig.async_server_threads)
    pub async_server_threads: i32,
    // @@protoc_insertion_point(field:grpc.testing.ServerConfig.core_limit)
    pub core_limit: i32,
    // @@protoc_insertion_point(field:grpc.testing.ServerConfig.payload_config)
    pub payload_config: ::protobufv3::MessageField<super::payloads::PayloadConfig>,
    // @@protoc_insertion_point(field:grpc.testing.ServerConfig.core_list)
    pub core_list: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:grpc.testing.ServerConfig.other_server_api)
    pub other_server_api: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.testing.ServerConfig.threads_per_cq)
    pub threads_per_cq: i32,
    // @@protoc_insertion_point(field:grpc.testing.ServerConfig.resource_quota_size)
    pub resource_quota_size: i32,
    // @@protoc_insertion_point(field:grpc.testing.ServerConfig.channel_args)
    pub channel_args: ::std::vec::Vec<ChannelArg>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ServerConfig.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerConfig {
    fn default() -> &'a ServerConfig {
        <ServerConfig as ::protobufv3::Message>::default_instance()
    }
}

impl ServerConfig {
    pub fn new() -> ServerConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_type",
            |m: &ServerConfig| { &m.server_type },
            |m: &mut ServerConfig| { &mut m.server_type },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, SecurityParams>(
            "security_params",
            |m: &ServerConfig| { &m.security_params },
            |m: &mut ServerConfig| { &mut m.security_params },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &ServerConfig| { &m.port },
            |m: &mut ServerConfig| { &mut m.port },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "async_server_threads",
            |m: &ServerConfig| { &m.async_server_threads },
            |m: &mut ServerConfig| { &mut m.async_server_threads },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "core_limit",
            |m: &ServerConfig| { &m.core_limit },
            |m: &mut ServerConfig| { &mut m.core_limit },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, super::payloads::PayloadConfig>(
            "payload_config",
            |m: &ServerConfig| { &m.payload_config },
            |m: &mut ServerConfig| { &mut m.payload_config },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "core_list",
            |m: &ServerConfig| { &m.core_list },
            |m: &mut ServerConfig| { &mut m.core_list },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "other_server_api",
            |m: &ServerConfig| { &m.other_server_api },
            |m: &mut ServerConfig| { &mut m.other_server_api },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "threads_per_cq",
            |m: &ServerConfig| { &m.threads_per_cq },
            |m: &mut ServerConfig| { &mut m.threads_per_cq },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "resource_quota_size",
            |m: &ServerConfig| { &m.resource_quota_size },
            |m: &mut ServerConfig| { &mut m.resource_quota_size },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channel_args",
            |m: &ServerConfig| { &m.channel_args },
            |m: &mut ServerConfig| { &mut m.channel_args },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ServerConfig>(
            "ServerConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ServerConfig {
    const NAME: &'static str = "ServerConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.security_params)?;
                },
                32 => {
                    self.port = is.read_int32()?;
                },
                56 => {
                    self.async_server_threads = is.read_int32()?;
                },
                64 => {
                    self.core_limit = is.read_int32()?;
                },
                74 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.payload_config)?;
                },
                82 => {
                    is.read_repeated_packed_int32_into(&mut self.core_list)?;
                },
                80 => {
                    self.core_list.push(is.read_int32()?);
                },
                90 => {
                    self.other_server_api = is.read_string()?;
                },
                96 => {
                    self.threads_per_cq = is.read_int32()?;
                },
                8008 => {
                    self.resource_quota_size = is.read_int32()?;
                },
                8018 => {
                    self.channel_args.push(is.read_message()?);
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.server_type != ::protobufv3::EnumOrUnknown::new(ServerType::SYNC_SERVER) {
            my_size += ::protobufv3::rt::int32_size(1, self.server_type.value());
        }
        if let Some(v) = self.security_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if self.port != 0 {
            my_size += ::protobufv3::rt::int32_size(4, self.port);
        }
        if self.async_server_threads != 0 {
            my_size += ::protobufv3::rt::int32_size(7, self.async_server_threads);
        }
        if self.core_limit != 0 {
            my_size += ::protobufv3::rt::int32_size(8, self.core_limit);
        }
        if let Some(v) = self.payload_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.core_list {
            my_size += ::protobufv3::rt::int32_size(10, *value);
        };
        if !self.other_server_api.is_empty() {
            my_size += ::protobufv3::rt::string_size(11, &self.other_server_api);
        }
        if self.threads_per_cq != 0 {
            my_size += ::protobufv3::rt::int32_size(12, self.threads_per_cq);
        }
        if self.resource_quota_size != 0 {
            my_size += ::protobufv3::rt::int32_size(1001, self.resource_quota_size);
        }
        for value in &self.channel_args {
            let len = value.compute_size();
            my_size += 2 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.server_type != ::protobufv3::EnumOrUnknown::new(ServerType::SYNC_SERVER) {
            os.write_enum(1, ::protobufv3::EnumOrUnknown::value(&self.server_type))?;
        }
        if let Some(v) = self.security_params.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.port != 0 {
            os.write_int32(4, self.port)?;
        }
        if self.async_server_threads != 0 {
            os.write_int32(7, self.async_server_threads)?;
        }
        if self.core_limit != 0 {
            os.write_int32(8, self.core_limit)?;
        }
        if let Some(v) = self.payload_config.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        for v in &self.core_list {
            os.write_int32(10, *v)?;
        };
        if !self.other_server_api.is_empty() {
            os.write_string(11, &self.other_server_api)?;
        }
        if self.threads_per_cq != 0 {
            os.write_int32(12, self.threads_per_cq)?;
        }
        if self.resource_quota_size != 0 {
            os.write_int32(1001, self.resource_quota_size)?;
        }
        for v in &self.channel_args {
            ::protobufv3::rt::write_message_field_with_cached_size(1002, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerConfig {
        ServerConfig::new()
    }

    fn clear(&mut self) {
        self.server_type = ::protobufv3::EnumOrUnknown::new(ServerType::SYNC_SERVER);
        self.security_params.clear();
        self.port = 0;
        self.async_server_threads = 0;
        self.core_limit = 0;
        self.payload_config.clear();
        self.core_list.clear();
        self.other_server_api.clear();
        self.threads_per_cq = 0;
        self.resource_quota_size = 0;
        self.channel_args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerConfig {
        static instance: ServerConfig = ServerConfig {
            server_type: ::protobufv3::EnumOrUnknown::from_i32(0),
            security_params: ::protobufv3::MessageField::none(),
            port: 0,
            async_server_threads: 0,
            core_limit: 0,
            payload_config: ::protobufv3::MessageField::none(),
            core_list: ::std::vec::Vec::new(),
            other_server_api: ::std::string::String::new(),
            threads_per_cq: 0,
            resource_quota_size: 0,
            channel_args: ::std::vec::Vec::new(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ServerConfig {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ServerConfig {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ServerArgs)
pub struct ServerArgs {
    // message oneof groups
    pub argtype: ::std::option::Option<server_args::Argtype>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ServerArgs.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerArgs {
    fn default() -> &'a ServerArgs {
        <ServerArgs as ::protobufv3::Message>::default_instance()
    }
}

impl ServerArgs {
    pub fn new() -> ServerArgs {
        ::std::default::Default::default()
    }

    // .grpc.testing.ServerConfig setup = 1;

    pub fn setup(&self) -> &ServerConfig {
        match self.argtype {
            ::std::option::Option::Some(server_args::Argtype::Setup(ref v)) => v,
            _ => <ServerConfig as ::protobufv3::Message>::default_instance(),
        }
    }

    pub fn clear_setup(&mut self) {
        self.argtype = ::std::option::Option::None;
    }

    pub fn has_setup(&self) -> bool {
        match self.argtype {
            ::std::option::Option::Some(server_args::Argtype::Setup(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setup(&mut self, v: ServerConfig) {
        self.argtype = ::std::option::Option::Some(server_args::Argtype::Setup(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setup(&mut self) -> &mut ServerConfig {
        if let ::std::option::Option::Some(server_args::Argtype::Setup(_)) = self.argtype {
        } else {
            self.argtype = ::std::option::Option::Some(server_args::Argtype::Setup(ServerConfig::new()));
        }
        match self.argtype {
            ::std::option::Option::Some(server_args::Argtype::Setup(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setup(&mut self) -> ServerConfig {
        if self.has_setup() {
            match self.argtype.take() {
                ::std::option::Option::Some(server_args::Argtype::Setup(v)) => v,
                _ => panic!(),
            }
        } else {
            ServerConfig::new()
        }
    }

    // .grpc.testing.Mark mark = 2;

    pub fn mark(&self) -> &Mark {
        match self.argtype {
            ::std::option::Option::Some(server_args::Argtype::Mark(ref v)) => v,
            _ => <Mark as ::protobufv3::Message>::default_instance(),
        }
    }

    pub fn clear_mark(&mut self) {
        self.argtype = ::std::option::Option::None;
    }

    pub fn has_mark(&self) -> bool {
        match self.argtype {
            ::std::option::Option::Some(server_args::Argtype::Mark(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mark(&mut self, v: Mark) {
        self.argtype = ::std::option::Option::Some(server_args::Argtype::Mark(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mark(&mut self) -> &mut Mark {
        if let ::std::option::Option::Some(server_args::Argtype::Mark(_)) = self.argtype {
        } else {
            self.argtype = ::std::option::Option::Some(server_args::Argtype::Mark(Mark::new()));
        }
        match self.argtype {
            ::std::option::Option::Some(server_args::Argtype::Mark(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mark(&mut self) -> Mark {
        if self.has_mark() {
            match self.argtype.take() {
                ::std::option::Option::Some(server_args::Argtype::Mark(v)) => v,
                _ => panic!(),
            }
        } else {
            Mark::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobufv3::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ServerConfig>(
            "setup",
            ServerArgs::has_setup,
            ServerArgs::setup,
            ServerArgs::mut_setup,
            ServerArgs::set_setup,
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Mark>(
            "mark",
            ServerArgs::has_mark,
            ServerArgs::mark,
            ServerArgs::mut_mark,
            ServerArgs::set_mark,
        ));
        oneofs.push(server_args::Argtype::generated_oneof_descriptor_data());
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ServerArgs>(
            "ServerArgs",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ServerArgs {
    const NAME: &'static str = "ServerArgs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.argtype = ::std::option::Option::Some(server_args::Argtype::Setup(is.read_message()?));
                },
                18 => {
                    self.argtype = ::std::option::Option::Some(server_args::Argtype::Mark(is.read_message()?));
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.argtype {
            match v {
                &server_args::Argtype::Setup(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
                },
                &server_args::Argtype::Mark(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.argtype {
            match v {
                &server_args::Argtype::Setup(ref v) => {
                    ::protobufv3::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &server_args::Argtype::Mark(ref v) => {
                    ::protobufv3::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerArgs {
        ServerArgs::new()
    }

    fn clear(&mut self) {
        self.argtype = ::std::option::Option::None;
        self.argtype = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerArgs {
        static instance: ServerArgs = ServerArgs {
            argtype: ::std::option::Option::None,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ServerArgs {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerArgs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerArgs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ServerArgs {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ServerArgs`
pub mod server_args {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:grpc.testing.ServerArgs.argtype)
    pub enum Argtype {
        // @@protoc_insertion_point(oneof_field:grpc.testing.ServerArgs.setup)
        Setup(super::ServerConfig),
        // @@protoc_insertion_point(oneof_field:grpc.testing.ServerArgs.mark)
        Mark(super::Mark),
    }

    impl ::protobufv3::Oneof for Argtype {
    }

    impl ::protobufv3::OneofFull for Argtype {
        fn descriptor() -> ::protobufv3::reflect::OneofDescriptor {
            static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::OneofDescriptor> = ::protobufv3::rt::Lazy::new();
            descriptor.get(|| <super::ServerArgs as ::protobufv3::MessageFull>::descriptor().oneof_by_name("argtype").unwrap()).clone()
        }
    }

    impl Argtype {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobufv3::reflect::GeneratedOneofDescriptorData {
            ::protobufv3::reflect::GeneratedOneofDescriptorData::new::<Argtype>("argtype")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ServerStatus)
pub struct ServerStatus {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.ServerStatus.stats)
    pub stats: ::protobufv3::MessageField<super::stats::ServerStats>,
    // @@protoc_insertion_point(field:grpc.testing.ServerStatus.port)
    pub port: i32,
    // @@protoc_insertion_point(field:grpc.testing.ServerStatus.cores)
    pub cores: i32,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ServerStatus.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerStatus {
    fn default() -> &'a ServerStatus {
        <ServerStatus as ::protobufv3::Message>::default_instance()
    }
}

impl ServerStatus {
    pub fn new() -> ServerStatus {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, super::stats::ServerStats>(
            "stats",
            |m: &ServerStatus| { &m.stats },
            |m: &mut ServerStatus| { &mut m.stats },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &ServerStatus| { &m.port },
            |m: &mut ServerStatus| { &mut m.port },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cores",
            |m: &ServerStatus| { &m.cores },
            |m: &mut ServerStatus| { &mut m.cores },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ServerStatus>(
            "ServerStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ServerStatus {
    const NAME: &'static str = "ServerStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                16 => {
                    self.port = is.read_int32()?;
                },
                24 => {
                    self.cores = is.read_int32()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if self.port != 0 {
            my_size += ::protobufv3::rt::int32_size(2, self.port);
        }
        if self.cores != 0 {
            my_size += ::protobufv3::rt::int32_size(3, self.cores);
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if let Some(v) = self.stats.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        if self.cores != 0 {
            os.write_int32(3, self.cores)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerStatus {
        ServerStatus::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.port = 0;
        self.cores = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerStatus {
        static instance: ServerStatus = ServerStatus {
            stats: ::protobufv3::MessageField::none(),
            port: 0,
            cores: 0,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ServerStatus {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ServerStatus {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.CoreRequest)
pub struct CoreRequest {
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.CoreRequest.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CoreRequest {
    fn default() -> &'a CoreRequest {
        <CoreRequest as ::protobufv3::Message>::default_instance()
    }
}

impl CoreRequest {
    pub fn new() -> CoreRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<CoreRequest>(
            "CoreRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for CoreRequest {
    const NAME: &'static str = "CoreRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CoreRequest {
        CoreRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CoreRequest {
        static instance: CoreRequest = CoreRequest {
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for CoreRequest {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CoreRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for CoreRequest {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.CoreResponse)
pub struct CoreResponse {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.CoreResponse.cores)
    pub cores: i32,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.CoreResponse.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CoreResponse {
    fn default() -> &'a CoreResponse {
        <CoreResponse as ::protobufv3::Message>::default_instance()
    }
}

impl CoreResponse {
    pub fn new() -> CoreResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cores",
            |m: &CoreResponse| { &m.cores },
            |m: &mut CoreResponse| { &mut m.cores },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<CoreResponse>(
            "CoreResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for CoreResponse {
    const NAME: &'static str = "CoreResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cores = is.read_int32()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.cores != 0 {
            my_size += ::protobufv3::rt::int32_size(1, self.cores);
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.cores != 0 {
            os.write_int32(1, self.cores)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CoreResponse {
        CoreResponse::new()
    }

    fn clear(&mut self) {
        self.cores = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CoreResponse {
        static instance: CoreResponse = CoreResponse {
            cores: 0,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for CoreResponse {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CoreResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for CoreResponse {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.Void)
pub struct Void {
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.Void.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Void {
    fn default() -> &'a Void {
        <Void as ::protobufv3::Message>::default_instance()
    }
}

impl Void {
    pub fn new() -> Void {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<Void>(
            "Void",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for Void {
    const NAME: &'static str = "Void";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Void {
        Void::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Void {
        static instance: Void = Void {
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for Void {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Void").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Void {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for Void {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.Scenario)
pub struct Scenario {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.Scenario.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:grpc.testing.Scenario.client_config)
    pub client_config: ::protobufv3::MessageField<ClientConfig>,
    // @@protoc_insertion_point(field:grpc.testing.Scenario.num_clients)
    pub num_clients: i32,
    // @@protoc_insertion_point(field:grpc.testing.Scenario.server_config)
    pub server_config: ::protobufv3::MessageField<ServerConfig>,
    // @@protoc_insertion_point(field:grpc.testing.Scenario.num_servers)
    pub num_servers: i32,
    // @@protoc_insertion_point(field:grpc.testing.Scenario.warmup_seconds)
    pub warmup_seconds: i32,
    // @@protoc_insertion_point(field:grpc.testing.Scenario.benchmark_seconds)
    pub benchmark_seconds: i32,
    // @@protoc_insertion_point(field:grpc.testing.Scenario.spawn_local_worker_count)
    pub spawn_local_worker_count: i32,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.Scenario.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Scenario {
    fn default() -> &'a Scenario {
        <Scenario as ::protobufv3::Message>::default_instance()
    }
}

impl Scenario {
    pub fn new() -> Scenario {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Scenario| { &m.name },
            |m: &mut Scenario| { &mut m.name },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, ClientConfig>(
            "client_config",
            |m: &Scenario| { &m.client_config },
            |m: &mut Scenario| { &mut m.client_config },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_clients",
            |m: &Scenario| { &m.num_clients },
            |m: &mut Scenario| { &mut m.num_clients },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, ServerConfig>(
            "server_config",
            |m: &Scenario| { &m.server_config },
            |m: &mut Scenario| { &mut m.server_config },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_servers",
            |m: &Scenario| { &m.num_servers },
            |m: &mut Scenario| { &mut m.num_servers },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "warmup_seconds",
            |m: &Scenario| { &m.warmup_seconds },
            |m: &mut Scenario| { &mut m.warmup_seconds },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "benchmark_seconds",
            |m: &Scenario| { &m.benchmark_seconds },
            |m: &mut Scenario| { &mut m.benchmark_seconds },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "spawn_local_worker_count",
            |m: &Scenario| { &m.spawn_local_worker_count },
            |m: &mut Scenario| { &mut m.spawn_local_worker_count },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<Scenario>(
            "Scenario",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for Scenario {
    const NAME: &'static str = "Scenario";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.client_config)?;
                },
                24 => {
                    self.num_clients = is.read_int32()?;
                },
                34 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.server_config)?;
                },
                40 => {
                    self.num_servers = is.read_int32()?;
                },
                48 => {
                    self.warmup_seconds = is.read_int32()?;
                },
                56 => {
                    self.benchmark_seconds = is.read_int32()?;
                },
                64 => {
                    self.spawn_local_worker_count = is.read_int32()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobufv3::rt::string_size(1, &self.name);
        }
        if let Some(v) = self.client_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if self.num_clients != 0 {
            my_size += ::protobufv3::rt::int32_size(3, self.num_clients);
        }
        if let Some(v) = self.server_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if self.num_servers != 0 {
            my_size += ::protobufv3::rt::int32_size(5, self.num_servers);
        }
        if self.warmup_seconds != 0 {
            my_size += ::protobufv3::rt::int32_size(6, self.warmup_seconds);
        }
        if self.benchmark_seconds != 0 {
            my_size += ::protobufv3::rt::int32_size(7, self.benchmark_seconds);
        }
        if self.spawn_local_worker_count != 0 {
            my_size += ::protobufv3::rt::int32_size(8, self.spawn_local_worker_count);
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(v) = self.client_config.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.num_clients != 0 {
            os.write_int32(3, self.num_clients)?;
        }
        if let Some(v) = self.server_config.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.num_servers != 0 {
            os.write_int32(5, self.num_servers)?;
        }
        if self.warmup_seconds != 0 {
            os.write_int32(6, self.warmup_seconds)?;
        }
        if self.benchmark_seconds != 0 {
            os.write_int32(7, self.benchmark_seconds)?;
        }
        if self.spawn_local_worker_count != 0 {
            os.write_int32(8, self.spawn_local_worker_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Scenario {
        Scenario::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.client_config.clear();
        self.num_clients = 0;
        self.server_config.clear();
        self.num_servers = 0;
        self.warmup_seconds = 0;
        self.benchmark_seconds = 0;
        self.spawn_local_worker_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Scenario {
        static instance: Scenario = Scenario {
            name: ::std::string::String::new(),
            client_config: ::protobufv3::MessageField::none(),
            num_clients: 0,
            server_config: ::protobufv3::MessageField::none(),
            num_servers: 0,
            warmup_seconds: 0,
            benchmark_seconds: 0,
            spawn_local_worker_count: 0,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for Scenario {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Scenario").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Scenario {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for Scenario {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.Scenarios)
pub struct Scenarios {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.Scenarios.scenarios)
    pub scenarios: ::std::vec::Vec<Scenario>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.Scenarios.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Scenarios {
    fn default() -> &'a Scenarios {
        <Scenarios as ::protobufv3::Message>::default_instance()
    }
}

impl Scenarios {
    pub fn new() -> Scenarios {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scenarios",
            |m: &Scenarios| { &m.scenarios },
            |m: &mut Scenarios| { &mut m.scenarios },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<Scenarios>(
            "Scenarios",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for Scenarios {
    const NAME: &'static str = "Scenarios";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.scenarios.push(is.read_message()?);
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.scenarios {
            let len = value.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        for v in &self.scenarios {
            ::protobufv3::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Scenarios {
        Scenarios::new()
    }

    fn clear(&mut self) {
        self.scenarios.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Scenarios {
        static instance: Scenarios = Scenarios {
            scenarios: ::std::vec::Vec::new(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for Scenarios {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Scenarios").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Scenarios {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for Scenarios {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ScenarioResultSummary)
pub struct ScenarioResultSummary {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.qps)
    pub qps: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.qps_per_server_core)
    pub qps_per_server_core: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.server_system_time)
    pub server_system_time: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.server_user_time)
    pub server_user_time: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.client_system_time)
    pub client_system_time: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.client_user_time)
    pub client_user_time: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.latency_50)
    pub latency_50: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.latency_90)
    pub latency_90: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.latency_95)
    pub latency_95: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.latency_99)
    pub latency_99: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.latency_999)
    pub latency_999: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.server_cpu_usage)
    pub server_cpu_usage: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.successful_requests_per_second)
    pub successful_requests_per_second: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.failed_requests_per_second)
    pub failed_requests_per_second: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.client_polls_per_request)
    pub client_polls_per_request: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.server_polls_per_request)
    pub server_polls_per_request: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.server_queries_per_cpu_sec)
    pub server_queries_per_cpu_sec: f64,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResultSummary.client_queries_per_cpu_sec)
    pub client_queries_per_cpu_sec: f64,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ScenarioResultSummary.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScenarioResultSummary {
    fn default() -> &'a ScenarioResultSummary {
        <ScenarioResultSummary as ::protobufv3::Message>::default_instance()
    }
}

impl ScenarioResultSummary {
    pub fn new() -> ScenarioResultSummary {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "qps",
            |m: &ScenarioResultSummary| { &m.qps },
            |m: &mut ScenarioResultSummary| { &mut m.qps },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "qps_per_server_core",
            |m: &ScenarioResultSummary| { &m.qps_per_server_core },
            |m: &mut ScenarioResultSummary| { &mut m.qps_per_server_core },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_system_time",
            |m: &ScenarioResultSummary| { &m.server_system_time },
            |m: &mut ScenarioResultSummary| { &mut m.server_system_time },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_user_time",
            |m: &ScenarioResultSummary| { &m.server_user_time },
            |m: &mut ScenarioResultSummary| { &mut m.server_user_time },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_system_time",
            |m: &ScenarioResultSummary| { &m.client_system_time },
            |m: &mut ScenarioResultSummary| { &mut m.client_system_time },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_user_time",
            |m: &ScenarioResultSummary| { &m.client_user_time },
            |m: &mut ScenarioResultSummary| { &mut m.client_user_time },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latency_50",
            |m: &ScenarioResultSummary| { &m.latency_50 },
            |m: &mut ScenarioResultSummary| { &mut m.latency_50 },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latency_90",
            |m: &ScenarioResultSummary| { &m.latency_90 },
            |m: &mut ScenarioResultSummary| { &mut m.latency_90 },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latency_95",
            |m: &ScenarioResultSummary| { &m.latency_95 },
            |m: &mut ScenarioResultSummary| { &mut m.latency_95 },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latency_99",
            |m: &ScenarioResultSummary| { &m.latency_99 },
            |m: &mut ScenarioResultSummary| { &mut m.latency_99 },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latency_999",
            |m: &ScenarioResultSummary| { &m.latency_999 },
            |m: &mut ScenarioResultSummary| { &mut m.latency_999 },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_cpu_usage",
            |m: &ScenarioResultSummary| { &m.server_cpu_usage },
            |m: &mut ScenarioResultSummary| { &mut m.server_cpu_usage },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "successful_requests_per_second",
            |m: &ScenarioResultSummary| { &m.successful_requests_per_second },
            |m: &mut ScenarioResultSummary| { &mut m.successful_requests_per_second },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failed_requests_per_second",
            |m: &ScenarioResultSummary| { &m.failed_requests_per_second },
            |m: &mut ScenarioResultSummary| { &mut m.failed_requests_per_second },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_polls_per_request",
            |m: &ScenarioResultSummary| { &m.client_polls_per_request },
            |m: &mut ScenarioResultSummary| { &mut m.client_polls_per_request },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_polls_per_request",
            |m: &ScenarioResultSummary| { &m.server_polls_per_request },
            |m: &mut ScenarioResultSummary| { &mut m.server_polls_per_request },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_queries_per_cpu_sec",
            |m: &ScenarioResultSummary| { &m.server_queries_per_cpu_sec },
            |m: &mut ScenarioResultSummary| { &mut m.server_queries_per_cpu_sec },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_queries_per_cpu_sec",
            |m: &ScenarioResultSummary| { &m.client_queries_per_cpu_sec },
            |m: &mut ScenarioResultSummary| { &mut m.client_queries_per_cpu_sec },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ScenarioResultSummary>(
            "ScenarioResultSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ScenarioResultSummary {
    const NAME: &'static str = "ScenarioResultSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.qps = is.read_double()?;
                },
                17 => {
                    self.qps_per_server_core = is.read_double()?;
                },
                25 => {
                    self.server_system_time = is.read_double()?;
                },
                33 => {
                    self.server_user_time = is.read_double()?;
                },
                41 => {
                    self.client_system_time = is.read_double()?;
                },
                49 => {
                    self.client_user_time = is.read_double()?;
                },
                57 => {
                    self.latency_50 = is.read_double()?;
                },
                65 => {
                    self.latency_90 = is.read_double()?;
                },
                73 => {
                    self.latency_95 = is.read_double()?;
                },
                81 => {
                    self.latency_99 = is.read_double()?;
                },
                89 => {
                    self.latency_999 = is.read_double()?;
                },
                97 => {
                    self.server_cpu_usage = is.read_double()?;
                },
                105 => {
                    self.successful_requests_per_second = is.read_double()?;
                },
                113 => {
                    self.failed_requests_per_second = is.read_double()?;
                },
                121 => {
                    self.client_polls_per_request = is.read_double()?;
                },
                129 => {
                    self.server_polls_per_request = is.read_double()?;
                },
                137 => {
                    self.server_queries_per_cpu_sec = is.read_double()?;
                },
                145 => {
                    self.client_queries_per_cpu_sec = is.read_double()?;
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.qps != 0. {
            my_size += 1 + 8;
        }
        if self.qps_per_server_core != 0. {
            my_size += 1 + 8;
        }
        if self.server_system_time != 0. {
            my_size += 1 + 8;
        }
        if self.server_user_time != 0. {
            my_size += 1 + 8;
        }
        if self.client_system_time != 0. {
            my_size += 1 + 8;
        }
        if self.client_user_time != 0. {
            my_size += 1 + 8;
        }
        if self.latency_50 != 0. {
            my_size += 1 + 8;
        }
        if self.latency_90 != 0. {
            my_size += 1 + 8;
        }
        if self.latency_95 != 0. {
            my_size += 1 + 8;
        }
        if self.latency_99 != 0. {
            my_size += 1 + 8;
        }
        if self.latency_999 != 0. {
            my_size += 1 + 8;
        }
        if self.server_cpu_usage != 0. {
            my_size += 1 + 8;
        }
        if self.successful_requests_per_second != 0. {
            my_size += 1 + 8;
        }
        if self.failed_requests_per_second != 0. {
            my_size += 1 + 8;
        }
        if self.client_polls_per_request != 0. {
            my_size += 1 + 8;
        }
        if self.server_polls_per_request != 0. {
            my_size += 2 + 8;
        }
        if self.server_queries_per_cpu_sec != 0. {
            my_size += 2 + 8;
        }
        if self.client_queries_per_cpu_sec != 0. {
            my_size += 2 + 8;
        }
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if self.qps != 0. {
            os.write_double(1, self.qps)?;
        }
        if self.qps_per_server_core != 0. {
            os.write_double(2, self.qps_per_server_core)?;
        }
        if self.server_system_time != 0. {
            os.write_double(3, self.server_system_time)?;
        }
        if self.server_user_time != 0. {
            os.write_double(4, self.server_user_time)?;
        }
        if self.client_system_time != 0. {
            os.write_double(5, self.client_system_time)?;
        }
        if self.client_user_time != 0. {
            os.write_double(6, self.client_user_time)?;
        }
        if self.latency_50 != 0. {
            os.write_double(7, self.latency_50)?;
        }
        if self.latency_90 != 0. {
            os.write_double(8, self.latency_90)?;
        }
        if self.latency_95 != 0. {
            os.write_double(9, self.latency_95)?;
        }
        if self.latency_99 != 0. {
            os.write_double(10, self.latency_99)?;
        }
        if self.latency_999 != 0. {
            os.write_double(11, self.latency_999)?;
        }
        if self.server_cpu_usage != 0. {
            os.write_double(12, self.server_cpu_usage)?;
        }
        if self.successful_requests_per_second != 0. {
            os.write_double(13, self.successful_requests_per_second)?;
        }
        if self.failed_requests_per_second != 0. {
            os.write_double(14, self.failed_requests_per_second)?;
        }
        if self.client_polls_per_request != 0. {
            os.write_double(15, self.client_polls_per_request)?;
        }
        if self.server_polls_per_request != 0. {
            os.write_double(16, self.server_polls_per_request)?;
        }
        if self.server_queries_per_cpu_sec != 0. {
            os.write_double(17, self.server_queries_per_cpu_sec)?;
        }
        if self.client_queries_per_cpu_sec != 0. {
            os.write_double(18, self.client_queries_per_cpu_sec)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScenarioResultSummary {
        ScenarioResultSummary::new()
    }

    fn clear(&mut self) {
        self.qps = 0.;
        self.qps_per_server_core = 0.;
        self.server_system_time = 0.;
        self.server_user_time = 0.;
        self.client_system_time = 0.;
        self.client_user_time = 0.;
        self.latency_50 = 0.;
        self.latency_90 = 0.;
        self.latency_95 = 0.;
        self.latency_99 = 0.;
        self.latency_999 = 0.;
        self.server_cpu_usage = 0.;
        self.successful_requests_per_second = 0.;
        self.failed_requests_per_second = 0.;
        self.client_polls_per_request = 0.;
        self.server_polls_per_request = 0.;
        self.server_queries_per_cpu_sec = 0.;
        self.client_queries_per_cpu_sec = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScenarioResultSummary {
        static instance: ScenarioResultSummary = ScenarioResultSummary {
            qps: 0.,
            qps_per_server_core: 0.,
            server_system_time: 0.,
            server_user_time: 0.,
            client_system_time: 0.,
            client_user_time: 0.,
            latency_50: 0.,
            latency_90: 0.,
            latency_95: 0.,
            latency_99: 0.,
            latency_999: 0.,
            server_cpu_usage: 0.,
            successful_requests_per_second: 0.,
            failed_requests_per_second: 0.,
            client_polls_per_request: 0.,
            server_polls_per_request: 0.,
            server_queries_per_cpu_sec: 0.,
            client_queries_per_cpu_sec: 0.,
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ScenarioResultSummary {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScenarioResultSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScenarioResultSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ScenarioResultSummary {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:grpc.testing.ScenarioResult)
pub struct ScenarioResult {
    // message fields
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResult.scenario)
    pub scenario: ::protobufv3::MessageField<Scenario>,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResult.latencies)
    pub latencies: ::protobufv3::MessageField<super::stats::HistogramData>,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResult.client_stats)
    pub client_stats: ::std::vec::Vec<super::stats::ClientStats>,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResult.server_stats)
    pub server_stats: ::std::vec::Vec<super::stats::ServerStats>,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResult.server_cores)
    pub server_cores: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResult.summary)
    pub summary: ::protobufv3::MessageField<ScenarioResultSummary>,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResult.client_success)
    pub client_success: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResult.server_success)
    pub server_success: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:grpc.testing.ScenarioResult.request_results)
    pub request_results: ::std::vec::Vec<super::stats::RequestResultCount>,
    // special fields
    // @@protoc_insertion_point(special_field:grpc.testing.ScenarioResult.special_fields)
    pub special_fields: ::protobufv3::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScenarioResult {
    fn default() -> &'a ScenarioResult {
        <ScenarioResult as ::protobufv3::Message>::default_instance()
    }
}

impl ScenarioResult {
    pub fn new() -> ScenarioResult {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobufv3::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, Scenario>(
            "scenario",
            |m: &ScenarioResult| { &m.scenario },
            |m: &mut ScenarioResult| { &mut m.scenario },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, super::stats::HistogramData>(
            "latencies",
            |m: &ScenarioResult| { &m.latencies },
            |m: &mut ScenarioResult| { &mut m.latencies },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "client_stats",
            |m: &ScenarioResult| { &m.client_stats },
            |m: &mut ScenarioResult| { &mut m.client_stats },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "server_stats",
            |m: &ScenarioResult| { &m.server_stats },
            |m: &mut ScenarioResult| { &mut m.server_stats },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "server_cores",
            |m: &ScenarioResult| { &m.server_cores },
            |m: &mut ScenarioResult| { &mut m.server_cores },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_message_field_accessor::<_, ScenarioResultSummary>(
            "summary",
            |m: &ScenarioResult| { &m.summary },
            |m: &mut ScenarioResult| { &mut m.summary },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "client_success",
            |m: &ScenarioResult| { &m.client_success },
            |m: &mut ScenarioResult| { &mut m.client_success },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "server_success",
            |m: &ScenarioResult| { &m.server_success },
            |m: &mut ScenarioResult| { &mut m.server_success },
        ));
        fields.push(::protobufv3::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "request_results",
            |m: &ScenarioResult| { &m.request_results },
            |m: &mut ScenarioResult| { &mut m.request_results },
        ));
        ::protobufv3::reflect::GeneratedMessageDescriptorData::new_2::<ScenarioResult>(
            "ScenarioResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobufv3::Message for ScenarioResult {
    const NAME: &'static str = "ScenarioResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobufv3::CodedInputStream<'_>) -> ::protobufv3::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.scenario)?;
                },
                18 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.latencies)?;
                },
                26 => {
                    self.client_stats.push(is.read_message()?);
                },
                34 => {
                    self.server_stats.push(is.read_message()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.server_cores)?;
                },
                40 => {
                    self.server_cores.push(is.read_int32()?);
                },
                50 => {
                    ::protobufv3::rt::read_singular_message_into_field(is, &mut self.summary)?;
                },
                58 => {
                    is.read_repeated_packed_bool_into(&mut self.client_success)?;
                },
                56 => {
                    self.client_success.push(is.read_bool()?);
                },
                66 => {
                    is.read_repeated_packed_bool_into(&mut self.server_success)?;
                },
                64 => {
                    self.server_success.push(is.read_bool()?);
                },
                74 => {
                    self.request_results.push(is.read_message()?);
                },
                tag => {
                    ::protobufv3::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.scenario.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.latencies.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.client_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.server_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.server_cores {
            my_size += ::protobufv3::rt::int32_size(5, *value);
        };
        if let Some(v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += 2 * self.client_success.len() as u64;
        my_size += 2 * self.server_success.len() as u64;
        for value in &self.request_results {
            let len = value.compute_size();
            my_size += 1 + ::protobufv3::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobufv3::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobufv3::CodedOutputStream<'_>) -> ::protobufv3::Result<()> {
        if let Some(v) = self.scenario.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.latencies.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.client_stats {
            ::protobufv3::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.server_stats {
            ::protobufv3::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.server_cores {
            os.write_int32(5, *v)?;
        };
        if let Some(v) = self.summary.as_ref() {
            ::protobufv3::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.client_success {
            os.write_bool(7, *v)?;
        };
        for v in &self.server_success {
            os.write_bool(8, *v)?;
        };
        for v in &self.request_results {
            ::protobufv3::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobufv3::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobufv3::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScenarioResult {
        ScenarioResult::new()
    }

    fn clear(&mut self) {
        self.scenario.clear();
        self.latencies.clear();
        self.client_stats.clear();
        self.server_stats.clear();
        self.server_cores.clear();
        self.summary.clear();
        self.client_success.clear();
        self.server_success.clear();
        self.request_results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScenarioResult {
        static instance: ScenarioResult = ScenarioResult {
            scenario: ::protobufv3::MessageField::none(),
            latencies: ::protobufv3::MessageField::none(),
            client_stats: ::std::vec::Vec::new(),
            server_stats: ::std::vec::Vec::new(),
            server_cores: ::std::vec::Vec::new(),
            summary: ::protobufv3::MessageField::none(),
            client_success: ::std::vec::Vec::new(),
            server_success: ::std::vec::Vec::new(),
            request_results: ::std::vec::Vec::new(),
            special_fields: ::protobufv3::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobufv3::MessageFull for ScenarioResult {
    fn descriptor() -> ::protobufv3::reflect::MessageDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::MessageDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScenarioResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScenarioResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobufv3::text_format::fmt(self, f)
    }
}

impl ::protobufv3::reflect::ProtobufValue for ScenarioResult {
    type RuntimeType = ::protobufv3::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:grpc.testing.ClientType)
pub enum ClientType {
    // @@protoc_insertion_point(enum_value:grpc.testing.ClientType.SYNC_CLIENT)
    SYNC_CLIENT = 0,
    // @@protoc_insertion_point(enum_value:grpc.testing.ClientType.ASYNC_CLIENT)
    ASYNC_CLIENT = 1,
    // @@protoc_insertion_point(enum_value:grpc.testing.ClientType.OTHER_CLIENT)
    OTHER_CLIENT = 2,
}

impl ::protobufv3::Enum for ClientType {
    const NAME: &'static str = "ClientType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientType> {
        match value {
            0 => ::std::option::Option::Some(ClientType::SYNC_CLIENT),
            1 => ::std::option::Option::Some(ClientType::ASYNC_CLIENT),
            2 => ::std::option::Option::Some(ClientType::OTHER_CLIENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClientType] = &[
        ClientType::SYNC_CLIENT,
        ClientType::ASYNC_CLIENT,
        ClientType::OTHER_CLIENT,
    ];
}

impl ::protobufv3::EnumFull for ClientType {
    fn enum_descriptor() -> ::protobufv3::reflect::EnumDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::EnumDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClientType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobufv3::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ClientType {
    fn default() -> Self {
        ClientType::SYNC_CLIENT
    }
}

impl ClientType {
    fn generated_enum_descriptor_data() -> ::protobufv3::reflect::GeneratedEnumDescriptorData {
        ::protobufv3::reflect::GeneratedEnumDescriptorData::new::<ClientType>("ClientType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:grpc.testing.ServerType)
pub enum ServerType {
    // @@protoc_insertion_point(enum_value:grpc.testing.ServerType.SYNC_SERVER)
    SYNC_SERVER = 0,
    // @@protoc_insertion_point(enum_value:grpc.testing.ServerType.ASYNC_SERVER)
    ASYNC_SERVER = 1,
    // @@protoc_insertion_point(enum_value:grpc.testing.ServerType.ASYNC_GENERIC_SERVER)
    ASYNC_GENERIC_SERVER = 2,
    // @@protoc_insertion_point(enum_value:grpc.testing.ServerType.OTHER_SERVER)
    OTHER_SERVER = 3,
}

impl ::protobufv3::Enum for ServerType {
    const NAME: &'static str = "ServerType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServerType> {
        match value {
            0 => ::std::option::Option::Some(ServerType::SYNC_SERVER),
            1 => ::std::option::Option::Some(ServerType::ASYNC_SERVER),
            2 => ::std::option::Option::Some(ServerType::ASYNC_GENERIC_SERVER),
            3 => ::std::option::Option::Some(ServerType::OTHER_SERVER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ServerType] = &[
        ServerType::SYNC_SERVER,
        ServerType::ASYNC_SERVER,
        ServerType::ASYNC_GENERIC_SERVER,
        ServerType::OTHER_SERVER,
    ];
}

impl ::protobufv3::EnumFull for ServerType {
    fn enum_descriptor() -> ::protobufv3::reflect::EnumDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::EnumDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ServerType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobufv3::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ServerType {
    fn default() -> Self {
        ServerType::SYNC_SERVER
    }
}

impl ServerType {
    fn generated_enum_descriptor_data() -> ::protobufv3::reflect::GeneratedEnumDescriptorData {
        ::protobufv3::reflect::GeneratedEnumDescriptorData::new::<ServerType>("ServerType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:grpc.testing.RpcType)
pub enum RpcType {
    // @@protoc_insertion_point(enum_value:grpc.testing.RpcType.UNARY)
    UNARY = 0,
    // @@protoc_insertion_point(enum_value:grpc.testing.RpcType.STREAMING)
    STREAMING = 1,
    // @@protoc_insertion_point(enum_value:grpc.testing.RpcType.STREAMING_FROM_CLIENT)
    STREAMING_FROM_CLIENT = 2,
    // @@protoc_insertion_point(enum_value:grpc.testing.RpcType.STREAMING_FROM_SERVER)
    STREAMING_FROM_SERVER = 3,
    // @@protoc_insertion_point(enum_value:grpc.testing.RpcType.STREAMING_BOTH_WAYS)
    STREAMING_BOTH_WAYS = 4,
}

impl ::protobufv3::Enum for RpcType {
    const NAME: &'static str = "RpcType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RpcType> {
        match value {
            0 => ::std::option::Option::Some(RpcType::UNARY),
            1 => ::std::option::Option::Some(RpcType::STREAMING),
            2 => ::std::option::Option::Some(RpcType::STREAMING_FROM_CLIENT),
            3 => ::std::option::Option::Some(RpcType::STREAMING_FROM_SERVER),
            4 => ::std::option::Option::Some(RpcType::STREAMING_BOTH_WAYS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RpcType] = &[
        RpcType::UNARY,
        RpcType::STREAMING,
        RpcType::STREAMING_FROM_CLIENT,
        RpcType::STREAMING_FROM_SERVER,
        RpcType::STREAMING_BOTH_WAYS,
    ];
}

impl ::protobufv3::EnumFull for RpcType {
    fn enum_descriptor() -> ::protobufv3::reflect::EnumDescriptor {
        static descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::EnumDescriptor> = ::protobufv3::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RpcType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobufv3::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RpcType {
    fn default() -> Self {
        RpcType::UNARY
    }
}

impl RpcType {
    fn generated_enum_descriptor_data() -> ::protobufv3::reflect::GeneratedEnumDescriptorData {
        ::protobufv3::reflect::GeneratedEnumDescriptorData::new::<RpcType>("RpcType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1agrpc/testing/control.proto\x12\x0cgrpc.testing\x1a\x1bgrpc/testing\
    /payloads.proto\x1a\x18grpc/testing/stats.proto\"2\n\rPoissonParams\x12!\
    \n\x0coffered_load\x18\x01\x20\x01(\x01R\x0bofferedLoad\"\x12\n\x10Close\
    dLoopParams\"\x90\x01\n\nLoadParams\x12A\n\x0bclosed_loop\x18\x01\x20\
    \x01(\x0b2\x1e.grpc.testing.ClosedLoopParamsH\0R\nclosedLoop\x127\n\x07p\
    oisson\x18\x02\x20\x01(\x0b2\x1b.grpc.testing.PoissonParamsH\0R\x07poiss\
    onB\x06\n\x04load\"\x7f\n\x0eSecurityParams\x12\x1e\n\x0buse_test_ca\x18\
    \x01\x20\x01(\x08R\tuseTestCa\x120\n\x14server_host_override\x18\x02\x20\
    \x01(\tR\x12serverHostOverride\x12\x1b\n\tcred_type\x18\x03\x20\x01(\tR\
    \x08credType\"g\n\nChannelArg\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04n\
    ame\x12\x1d\n\tstr_value\x18\x02\x20\x01(\tH\0R\x08strValue\x12\x1d\n\ti\
    nt_value\x18\x03\x20\x01(\x05H\0R\x08intValueB\x07\n\x05value\"\xc7\x06\
    \n\x0cClientConfig\x12%\n\x0eserver_targets\x18\x01\x20\x03(\tR\rserverT\
    argets\x129\n\x0bclient_type\x18\x02\x20\x01(\x0e2\x18.grpc.testing.Clie\
    ntTypeR\nclientType\x12E\n\x0fsecurity_params\x18\x03\x20\x01(\x0b2\x1c.\
    grpc.testing.SecurityParamsR\x0esecurityParams\x12?\n\x1coutstanding_rpc\
    s_per_channel\x18\x04\x20\x01(\x05R\x19outstandingRpcsPerChannel\x12'\n\
    \x0fclient_channels\x18\x05\x20\x01(\x05R\x0eclientChannels\x120\n\x14as\
    ync_client_threads\x18\x07\x20\x01(\x05R\x12asyncClientThreads\x120\n\
    \x08rpc_type\x18\x08\x20\x01(\x0e2\x15.grpc.testing.RpcTypeR\x07rpcType\
    \x129\n\x0bload_params\x18\n\x20\x01(\x0b2\x18.grpc.testing.LoadParamsR\
    \nloadParams\x12B\n\x0epayload_config\x18\x0b\x20\x01(\x0b2\x1b.grpc.tes\
    ting.PayloadConfigR\rpayloadConfig\x12H\n\x10histogram_params\x18\x0c\
    \x20\x01(\x0b2\x1d.grpc.testing.HistogramParamsR\x0fhistogramParams\x12\
    \x1b\n\tcore_list\x18\r\x20\x03(\x05R\x08coreList\x12\x1d\n\ncore_limit\
    \x18\x0e\x20\x01(\x05R\tcoreLimit\x12(\n\x10other_client_api\x18\x0f\x20\
    \x01(\tR\x0eotherClientApi\x12;\n\x0cchannel_args\x18\x10\x20\x03(\x0b2\
    \x18.grpc.testing.ChannelArgR\x0bchannelArgs\x12$\n\x0ethreads_per_cq\
    \x18\x11\x20\x01(\x05R\x0cthreadsPerCq\x12.\n\x13messages_per_stream\x18\
    \x12\x20\x01(\x05R\x11messagesPerStream\"?\n\x0cClientStatus\x12/\n\x05s\
    tats\x18\x01\x20\x01(\x0b2\x19.grpc.testing.ClientStatsR\x05stats\"\x1c\
    \n\x04Mark\x12\x14\n\x05reset\x18\x01\x20\x01(\x08R\x05reset\"u\n\nClien\
    tArgs\x122\n\x05setup\x18\x01\x20\x01(\x0b2\x1a.grpc.testing.ClientConfi\
    gH\0R\x05setup\x12(\n\x04mark\x18\x02\x20\x01(\x0b2\x12.grpc.testing.Mar\
    kH\0R\x04markB\t\n\x07argtype\"\x95\x04\n\x0cServerConfig\x129\n\x0bserv\
    er_type\x18\x01\x20\x01(\x0e2\x18.grpc.testing.ServerTypeR\nserverType\
    \x12E\n\x0fsecurity_params\x18\x02\x20\x01(\x0b2\x1c.grpc.testing.Securi\
    tyParamsR\x0esecurityParams\x12\x12\n\x04port\x18\x04\x20\x01(\x05R\x04p\
    ort\x120\n\x14async_server_threads\x18\x07\x20\x01(\x05R\x12asyncServerT\
    hreads\x12\x1d\n\ncore_limit\x18\x08\x20\x01(\x05R\tcoreLimit\x12B\n\x0e\
    payload_config\x18\t\x20\x01(\x0b2\x1b.grpc.testing.PayloadConfigR\rpayl\
    oadConfig\x12\x1b\n\tcore_list\x18\n\x20\x03(\x05R\x08coreList\x12(\n\
    \x10other_server_api\x18\x0b\x20\x01(\tR\x0eotherServerApi\x12$\n\x0ethr\
    eads_per_cq\x18\x0c\x20\x01(\x05R\x0cthreadsPerCq\x12/\n\x13resource_quo\
    ta_size\x18\xe9\x07\x20\x01(\x05R\x11resourceQuotaSize\x12<\n\x0cchannel\
    _args\x18\xea\x07\x20\x03(\x0b2\x18.grpc.testing.ChannelArgR\x0bchannelA\
    rgs\"u\n\nServerArgs\x122\n\x05setup\x18\x01\x20\x01(\x0b2\x1a.grpc.test\
    ing.ServerConfigH\0R\x05setup\x12(\n\x04mark\x18\x02\x20\x01(\x0b2\x12.g\
    rpc.testing.MarkH\0R\x04markB\t\n\x07argtype\"i\n\x0cServerStatus\x12/\n\
    \x05stats\x18\x01\x20\x01(\x0b2\x19.grpc.testing.ServerStatsR\x05stats\
    \x12\x12\n\x04port\x18\x02\x20\x01(\x05R\x04port\x12\x14\n\x05cores\x18\
    \x03\x20\x01(\x05R\x05cores\"\r\n\x0bCoreRequest\"$\n\x0cCoreResponse\
    \x12\x14\n\x05cores\x18\x01\x20\x01(\x05R\x05cores\"\x06\n\x04Void\"\xef\
    \x02\n\x08Scenario\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12?\n\
    \rclient_config\x18\x02\x20\x01(\x0b2\x1a.grpc.testing.ClientConfigR\x0c\
    clientConfig\x12\x1f\n\x0bnum_clients\x18\x03\x20\x01(\x05R\nnumClients\
    \x12?\n\rserver_config\x18\x04\x20\x01(\x0b2\x1a.grpc.testing.ServerConf\
    igR\x0cserverConfig\x12\x1f\n\x0bnum_servers\x18\x05\x20\x01(\x05R\nnumS\
    ervers\x12%\n\x0ewarmup_seconds\x18\x06\x20\x01(\x05R\rwarmupSeconds\x12\
    +\n\x11benchmark_seconds\x18\x07\x20\x01(\x05R\x10benchmarkSeconds\x127\
    \n\x18spawn_local_worker_count\x18\x08\x20\x01(\x05R\x15spawnLocalWorker\
    Count\"A\n\tScenarios\x124\n\tscenarios\x18\x01\x20\x03(\x0b2\x16.grpc.t\
    esting.ScenarioR\tscenarios\"\xbb\x06\n\x15ScenarioResultSummary\x12\x10\
    \n\x03qps\x18\x01\x20\x01(\x01R\x03qps\x12-\n\x13qps_per_server_core\x18\
    \x02\x20\x01(\x01R\x10qpsPerServerCore\x12,\n\x12server_system_time\x18\
    \x03\x20\x01(\x01R\x10serverSystemTime\x12(\n\x10server_user_time\x18\
    \x04\x20\x01(\x01R\x0eserverUserTime\x12,\n\x12client_system_time\x18\
    \x05\x20\x01(\x01R\x10clientSystemTime\x12(\n\x10client_user_time\x18\
    \x06\x20\x01(\x01R\x0eclientUserTime\x12\x1d\n\nlatency_50\x18\x07\x20\
    \x01(\x01R\tlatency50\x12\x1d\n\nlatency_90\x18\x08\x20\x01(\x01R\tlaten\
    cy90\x12\x1d\n\nlatency_95\x18\t\x20\x01(\x01R\tlatency95\x12\x1d\n\nlat\
    ency_99\x18\n\x20\x01(\x01R\tlatency99\x12\x1f\n\x0blatency_999\x18\x0b\
    \x20\x01(\x01R\nlatency999\x12(\n\x10server_cpu_usage\x18\x0c\x20\x01(\
    \x01R\x0eserverCpuUsage\x12C\n\x1esuccessful_requests_per_second\x18\r\
    \x20\x01(\x01R\x1bsuccessfulRequestsPerSecond\x12;\n\x1afailed_requests_\
    per_second\x18\x0e\x20\x01(\x01R\x17failedRequestsPerSecond\x127\n\x18cl\
    ient_polls_per_request\x18\x0f\x20\x01(\x01R\x15clientPollsPerRequest\
    \x127\n\x18server_polls_per_request\x18\x10\x20\x01(\x01R\x15serverPolls\
    PerRequest\x12:\n\x1aserver_queries_per_cpu_sec\x18\x11\x20\x01(\x01R\
    \x16serverQueriesPerCpuSec\x12:\n\x1aclient_queries_per_cpu_sec\x18\x12\
    \x20\x01(\x01R\x16clientQueriesPerCpuSec\"\xf6\x03\n\x0eScenarioResult\
    \x122\n\x08scenario\x18\x01\x20\x01(\x0b2\x16.grpc.testing.ScenarioR\x08\
    scenario\x129\n\tlatencies\x18\x02\x20\x01(\x0b2\x1b.grpc.testing.Histog\
    ramDataR\tlatencies\x12<\n\x0cclient_stats\x18\x03\x20\x03(\x0b2\x19.grp\
    c.testing.ClientStatsR\x0bclientStats\x12<\n\x0cserver_stats\x18\x04\x20\
    \x03(\x0b2\x19.grpc.testing.ServerStatsR\x0bserverStats\x12!\n\x0cserver\
    _cores\x18\x05\x20\x03(\x05R\x0bserverCores\x12=\n\x07summary\x18\x06\
    \x20\x01(\x0b2#.grpc.testing.ScenarioResultSummaryR\x07summary\x12%\n\
    \x0eclient_success\x18\x07\x20\x03(\x08R\rclientSuccess\x12%\n\x0eserver\
    _success\x18\x08\x20\x03(\x08R\rserverSuccess\x12I\n\x0frequest_results\
    \x18\t\x20\x03(\x0b2\x20.grpc.testing.RequestResultCountR\x0erequestResu\
    lts*A\n\nClientType\x12\x0f\n\x0bSYNC_CLIENT\x10\0\x12\x10\n\x0cASYNC_CL\
    IENT\x10\x01\x12\x10\n\x0cOTHER_CLIENT\x10\x02*[\n\nServerType\x12\x0f\n\
    \x0bSYNC_SERVER\x10\0\x12\x10\n\x0cASYNC_SERVER\x10\x01\x12\x18\n\x14ASY\
    NC_GENERIC_SERVER\x10\x02\x12\x10\n\x0cOTHER_SERVER\x10\x03*r\n\x07RpcTy\
    pe\x12\t\n\x05UNARY\x10\0\x12\r\n\tSTREAMING\x10\x01\x12\x19\n\x15STREAM\
    ING_FROM_CLIENT\x10\x02\x12\x19\n\x15STREAMING_FROM_SERVER\x10\x03\x12\
    \x17\n\x13STREAMING_BOTH_WAYS\x10\x04b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobufv3::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobufv3::rt::Lazy<::protobufv3::descriptor::FileDescriptorProto> = ::protobufv3::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobufv3::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobufv3::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobufv3::rt::Lazy<::protobufv3::reflect::GeneratedFileDescriptor> = ::protobufv3::rt::Lazy::new();
    static file_descriptor: ::protobufv3::rt::Lazy<::protobufv3::reflect::FileDescriptor> = ::protobufv3::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::payloads::file_descriptor().clone());
            deps.push(super::stats::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(19);
            messages.push(PoissonParams::generated_message_descriptor_data());
            messages.push(ClosedLoopParams::generated_message_descriptor_data());
            messages.push(LoadParams::generated_message_descriptor_data());
            messages.push(SecurityParams::generated_message_descriptor_data());
            messages.push(ChannelArg::generated_message_descriptor_data());
            messages.push(ClientConfig::generated_message_descriptor_data());
            messages.push(ClientStatus::generated_message_descriptor_data());
            messages.push(Mark::generated_message_descriptor_data());
            messages.push(ClientArgs::generated_message_descriptor_data());
            messages.push(ServerConfig::generated_message_descriptor_data());
            messages.push(ServerArgs::generated_message_descriptor_data());
            messages.push(ServerStatus::generated_message_descriptor_data());
            messages.push(CoreRequest::generated_message_descriptor_data());
            messages.push(CoreResponse::generated_message_descriptor_data());
            messages.push(Void::generated_message_descriptor_data());
            messages.push(Scenario::generated_message_descriptor_data());
            messages.push(Scenarios::generated_message_descriptor_data());
            messages.push(ScenarioResultSummary::generated_message_descriptor_data());
            messages.push(ScenarioResult::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(ClientType::generated_enum_descriptor_data());
            enums.push(ServerType::generated_enum_descriptor_data());
            enums.push(RpcType::generated_enum_descriptor_data());
            ::protobufv3::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobufv3::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
