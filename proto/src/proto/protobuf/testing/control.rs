// This file is generated by rust-protobuf 2.8.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `grpc/testing/control.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.

#[derive(PartialEq,Clone,Default)]
pub struct PoissonParams {
    // message fields
    pub offered_load: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PoissonParams {
    fn default() -> &'a PoissonParams {
        <PoissonParams as ::protobuf::Message>::default_instance()
    }
}

impl PoissonParams {
    pub fn new() -> PoissonParams {
        ::std::default::Default::default()
    }

    // double offered_load = 1;


    pub fn get_offered_load(&self) -> f64 {
        self.offered_load
    }
    pub fn clear_offered_load(&mut self) {
        self.offered_load = 0.;
    }

    // Param is passed by value, moved
    pub fn set_offered_load(&mut self, v: f64) {
        self.offered_load = v;
    }
}

impl ::protobuf::Message for PoissonParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.offered_load = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.offered_load != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.offered_load != 0. {
            os.write_double(1, self.offered_load)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PoissonParams {
        PoissonParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "offered_load",
                    |m: &PoissonParams| { &m.offered_load },
                    |m: &mut PoissonParams| { &mut m.offered_load },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PoissonParams>(
                    "PoissonParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PoissonParams {
        static mut instance: ::protobuf::lazy::Lazy<PoissonParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PoissonParams,
        };
        unsafe {
            instance.get(PoissonParams::new)
        }
    }
}

impl ::protobuf::Clear for PoissonParams {
    fn clear(&mut self) {
        self.offered_load = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PoissonParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoissonParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClosedLoopParams {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClosedLoopParams {
    fn default() -> &'a ClosedLoopParams {
        <ClosedLoopParams as ::protobuf::Message>::default_instance()
    }
}

impl ClosedLoopParams {
    pub fn new() -> ClosedLoopParams {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ClosedLoopParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClosedLoopParams {
        ClosedLoopParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ClosedLoopParams>(
                    "ClosedLoopParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClosedLoopParams {
        static mut instance: ::protobuf::lazy::Lazy<ClosedLoopParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClosedLoopParams,
        };
        unsafe {
            instance.get(ClosedLoopParams::new)
        }
    }
}

impl ::protobuf::Clear for ClosedLoopParams {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClosedLoopParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClosedLoopParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadParams {
    // message oneof groups
    pub load: ::std::option::Option<LoadParams_oneof_load>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadParams {
    fn default() -> &'a LoadParams {
        <LoadParams as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum LoadParams_oneof_load {
    closed_loop(ClosedLoopParams),
    poisson(PoissonParams),
}

impl LoadParams {
    pub fn new() -> LoadParams {
        ::std::default::Default::default()
    }

    // .grpc.testing.ClosedLoopParams closed_loop = 1;


    pub fn get_closed_loop(&self) -> &ClosedLoopParams {
        match self.load {
            ::std::option::Option::Some(LoadParams_oneof_load::closed_loop(ref v)) => v,
            _ => ClosedLoopParams::default_instance(),
        }
    }
    pub fn clear_closed_loop(&mut self) {
        self.load = ::std::option::Option::None;
    }

    pub fn has_closed_loop(&self) -> bool {
        match self.load {
            ::std::option::Option::Some(LoadParams_oneof_load::closed_loop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_closed_loop(&mut self, v: ClosedLoopParams) {
        self.load = ::std::option::Option::Some(LoadParams_oneof_load::closed_loop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_closed_loop(&mut self) -> &mut ClosedLoopParams {
        if let ::std::option::Option::Some(LoadParams_oneof_load::closed_loop(_)) = self.load {
        } else {
            self.load = ::std::option::Option::Some(LoadParams_oneof_load::closed_loop(ClosedLoopParams::new()));
        }
        match self.load {
            ::std::option::Option::Some(LoadParams_oneof_load::closed_loop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_closed_loop(&mut self) -> ClosedLoopParams {
        if self.has_closed_loop() {
            match self.load.take() {
                ::std::option::Option::Some(LoadParams_oneof_load::closed_loop(v)) => v,
                _ => panic!(),
            }
        } else {
            ClosedLoopParams::new()
        }
    }

    // .grpc.testing.PoissonParams poisson = 2;


    pub fn get_poisson(&self) -> &PoissonParams {
        match self.load {
            ::std::option::Option::Some(LoadParams_oneof_load::poisson(ref v)) => v,
            _ => PoissonParams::default_instance(),
        }
    }
    pub fn clear_poisson(&mut self) {
        self.load = ::std::option::Option::None;
    }

    pub fn has_poisson(&self) -> bool {
        match self.load {
            ::std::option::Option::Some(LoadParams_oneof_load::poisson(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_poisson(&mut self, v: PoissonParams) {
        self.load = ::std::option::Option::Some(LoadParams_oneof_load::poisson(v))
    }

    // Mutable pointer to the field.
    pub fn mut_poisson(&mut self) -> &mut PoissonParams {
        if let ::std::option::Option::Some(LoadParams_oneof_load::poisson(_)) = self.load {
        } else {
            self.load = ::std::option::Option::Some(LoadParams_oneof_load::poisson(PoissonParams::new()));
        }
        match self.load {
            ::std::option::Option::Some(LoadParams_oneof_load::poisson(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_poisson(&mut self) -> PoissonParams {
        if self.has_poisson() {
            match self.load.take() {
                ::std::option::Option::Some(LoadParams_oneof_load::poisson(v)) => v,
                _ => panic!(),
            }
        } else {
            PoissonParams::new()
        }
    }
}

impl ::protobuf::Message for LoadParams {
    fn is_initialized(&self) -> bool {
        if let Some(LoadParams_oneof_load::closed_loop(ref v)) = self.load {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(LoadParams_oneof_load::poisson(ref v)) = self.load {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.load = ::std::option::Option::Some(LoadParams_oneof_load::closed_loop(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.load = ::std::option::Option::Some(LoadParams_oneof_load::poisson(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.load {
            match v {
                &LoadParams_oneof_load::closed_loop(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &LoadParams_oneof_load::poisson(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.load {
            match v {
                &LoadParams_oneof_load::closed_loop(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &LoadParams_oneof_load::poisson(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadParams {
        LoadParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ClosedLoopParams>(
                    "closed_loop",
                    LoadParams::has_closed_loop,
                    LoadParams::get_closed_loop,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PoissonParams>(
                    "poisson",
                    LoadParams::has_poisson,
                    LoadParams::get_poisson,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LoadParams>(
                    "LoadParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LoadParams {
        static mut instance: ::protobuf::lazy::Lazy<LoadParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LoadParams,
        };
        unsafe {
            instance.get(LoadParams::new)
        }
    }
}

impl ::protobuf::Clear for LoadParams {
    fn clear(&mut self) {
        self.load = ::std::option::Option::None;
        self.load = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecurityParams {
    // message fields
    pub use_test_ca: bool,
    pub server_host_override: ::std::string::String,
    pub cred_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecurityParams {
    fn default() -> &'a SecurityParams {
        <SecurityParams as ::protobuf::Message>::default_instance()
    }
}

impl SecurityParams {
    pub fn new() -> SecurityParams {
        ::std::default::Default::default()
    }

    // bool use_test_ca = 1;


    pub fn get_use_test_ca(&self) -> bool {
        self.use_test_ca
    }
    pub fn clear_use_test_ca(&mut self) {
        self.use_test_ca = false;
    }

    // Param is passed by value, moved
    pub fn set_use_test_ca(&mut self, v: bool) {
        self.use_test_ca = v;
    }

    // string server_host_override = 2;


    pub fn get_server_host_override(&self) -> &str {
        &self.server_host_override
    }
    pub fn clear_server_host_override(&mut self) {
        self.server_host_override.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_host_override(&mut self, v: ::std::string::String) {
        self.server_host_override = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_host_override(&mut self) -> &mut ::std::string::String {
        &mut self.server_host_override
    }

    // Take field
    pub fn take_server_host_override(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.server_host_override, ::std::string::String::new())
    }

    // string cred_type = 3;


    pub fn get_cred_type(&self) -> &str {
        &self.cred_type
    }
    pub fn clear_cred_type(&mut self) {
        self.cred_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_cred_type(&mut self, v: ::std::string::String) {
        self.cred_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cred_type(&mut self) -> &mut ::std::string::String {
        &mut self.cred_type
    }

    // Take field
    pub fn take_cred_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cred_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SecurityParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_test_ca = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.server_host_override)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cred_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.use_test_ca != false {
            my_size += 2;
        }
        if !self.server_host_override.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.server_host_override);
        }
        if !self.cred_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cred_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.use_test_ca != false {
            os.write_bool(1, self.use_test_ca)?;
        }
        if !self.server_host_override.is_empty() {
            os.write_string(2, &self.server_host_override)?;
        }
        if !self.cred_type.is_empty() {
            os.write_string(3, &self.cred_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecurityParams {
        SecurityParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_test_ca",
                    |m: &SecurityParams| { &m.use_test_ca },
                    |m: &mut SecurityParams| { &mut m.use_test_ca },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "server_host_override",
                    |m: &SecurityParams| { &m.server_host_override },
                    |m: &mut SecurityParams| { &mut m.server_host_override },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cred_type",
                    |m: &SecurityParams| { &m.cred_type },
                    |m: &mut SecurityParams| { &mut m.cred_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SecurityParams>(
                    "SecurityParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SecurityParams {
        static mut instance: ::protobuf::lazy::Lazy<SecurityParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SecurityParams,
        };
        unsafe {
            instance.get(SecurityParams::new)
        }
    }
}

impl ::protobuf::Clear for SecurityParams {
    fn clear(&mut self) {
        self.use_test_ca = false;
        self.server_host_override.clear();
        self.cred_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecurityParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelArg {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub value: ::std::option::Option<ChannelArg_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelArg {
    fn default() -> &'a ChannelArg {
        <ChannelArg as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ChannelArg_oneof_value {
    str_value(::std::string::String),
    int_value(i32),
}

impl ChannelArg {
    pub fn new() -> ChannelArg {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string str_value = 2;


    pub fn get_str_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(ChannelArg_oneof_value::str_value(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_str_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_str_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(ChannelArg_oneof_value::str_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_str_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(ChannelArg_oneof_value::str_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_str_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ChannelArg_oneof_value::str_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(ChannelArg_oneof_value::str_value(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(ChannelArg_oneof_value::str_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_str_value(&mut self) -> ::std::string::String {
        if self.has_str_value() {
            match self.value.take() {
                ::std::option::Option::Some(ChannelArg_oneof_value::str_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // int32 int_value = 3;


    pub fn get_int_value(&self) -> i32 {
        match self.value {
            ::std::option::Option::Some(ChannelArg_oneof_value::int_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(ChannelArg_oneof_value::int_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(ChannelArg_oneof_value::int_value(v))
    }
}

impl ::protobuf::Message for ChannelArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(ChannelArg_oneof_value::str_value(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(ChannelArg_oneof_value::int_value(is.read_int32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &ChannelArg_oneof_value::str_value(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &ChannelArg_oneof_value::int_value(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &ChannelArg_oneof_value::str_value(ref v) => {
                    os.write_string(2, v)?;
                },
                &ChannelArg_oneof_value::int_value(v) => {
                    os.write_int32(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelArg {
        ChannelArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ChannelArg| { &m.name },
                    |m: &mut ChannelArg| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "str_value",
                    ChannelArg::has_str_value,
                    ChannelArg::get_str_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                    "int_value",
                    ChannelArg::has_int_value,
                    ChannelArg::get_int_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelArg>(
                    "ChannelArg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelArg {
        static mut instance: ::protobuf::lazy::Lazy<ChannelArg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelArg,
        };
        unsafe {
            instance.get(ChannelArg::new)
        }
    }
}

impl ::protobuf::Clear for ChannelArg {
    fn clear(&mut self) {
        self.name.clear();
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelArg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientConfig {
    // message fields
    pub server_targets: ::protobuf::RepeatedField<::std::string::String>,
    pub client_type: ClientType,
    pub security_params: ::protobuf::SingularPtrField<SecurityParams>,
    pub outstanding_rpcs_per_channel: i32,
    pub client_channels: i32,
    pub async_client_threads: i32,
    pub rpc_type: RpcType,
    pub load_params: ::protobuf::SingularPtrField<LoadParams>,
    pub payload_config: ::protobuf::SingularPtrField<super::payloads::PayloadConfig>,
    pub histogram_params: ::protobuf::SingularPtrField<super::stats::HistogramParams>,
    pub core_list: ::std::vec::Vec<i32>,
    pub core_limit: i32,
    pub other_client_api: ::std::string::String,
    pub channel_args: ::protobuf::RepeatedField<ChannelArg>,
    pub threads_per_cq: i32,
    pub messages_per_stream: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientConfig {
    fn default() -> &'a ClientConfig {
        <ClientConfig as ::protobuf::Message>::default_instance()
    }
}

impl ClientConfig {
    pub fn new() -> ClientConfig {
        ::std::default::Default::default()
    }

    // repeated string server_targets = 1;


    pub fn get_server_targets(&self) -> &[::std::string::String] {
        &self.server_targets
    }
    pub fn clear_server_targets(&mut self) {
        self.server_targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_targets(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.server_targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_server_targets(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.server_targets
    }

    // Take field
    pub fn take_server_targets(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.server_targets, ::protobuf::RepeatedField::new())
    }

    // .grpc.testing.ClientType client_type = 2;


    pub fn get_client_type(&self) -> ClientType {
        self.client_type
    }
    pub fn clear_client_type(&mut self) {
        self.client_type = ClientType::SYNC_CLIENT;
    }

    // Param is passed by value, moved
    pub fn set_client_type(&mut self, v: ClientType) {
        self.client_type = v;
    }

    // .grpc.testing.SecurityParams security_params = 3;


    pub fn get_security_params(&self) -> &SecurityParams {
        self.security_params.as_ref().unwrap_or_else(|| SecurityParams::default_instance())
    }
    pub fn clear_security_params(&mut self) {
        self.security_params.clear();
    }

    pub fn has_security_params(&self) -> bool {
        self.security_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_security_params(&mut self, v: SecurityParams) {
        self.security_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security_params(&mut self) -> &mut SecurityParams {
        if self.security_params.is_none() {
            self.security_params.set_default();
        }
        self.security_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_security_params(&mut self) -> SecurityParams {
        self.security_params.take().unwrap_or_else(|| SecurityParams::new())
    }

    // int32 outstanding_rpcs_per_channel = 4;


    pub fn get_outstanding_rpcs_per_channel(&self) -> i32 {
        self.outstanding_rpcs_per_channel
    }
    pub fn clear_outstanding_rpcs_per_channel(&mut self) {
        self.outstanding_rpcs_per_channel = 0;
    }

    // Param is passed by value, moved
    pub fn set_outstanding_rpcs_per_channel(&mut self, v: i32) {
        self.outstanding_rpcs_per_channel = v;
    }

    // int32 client_channels = 5;


    pub fn get_client_channels(&self) -> i32 {
        self.client_channels
    }
    pub fn clear_client_channels(&mut self) {
        self.client_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_client_channels(&mut self, v: i32) {
        self.client_channels = v;
    }

    // int32 async_client_threads = 7;


    pub fn get_async_client_threads(&self) -> i32 {
        self.async_client_threads
    }
    pub fn clear_async_client_threads(&mut self) {
        self.async_client_threads = 0;
    }

    // Param is passed by value, moved
    pub fn set_async_client_threads(&mut self, v: i32) {
        self.async_client_threads = v;
    }

    // .grpc.testing.RpcType rpc_type = 8;


    pub fn get_rpc_type(&self) -> RpcType {
        self.rpc_type
    }
    pub fn clear_rpc_type(&mut self) {
        self.rpc_type = RpcType::UNARY;
    }

    // Param is passed by value, moved
    pub fn set_rpc_type(&mut self, v: RpcType) {
        self.rpc_type = v;
    }

    // .grpc.testing.LoadParams load_params = 10;


    pub fn get_load_params(&self) -> &LoadParams {
        self.load_params.as_ref().unwrap_or_else(|| LoadParams::default_instance())
    }
    pub fn clear_load_params(&mut self) {
        self.load_params.clear();
    }

    pub fn has_load_params(&self) -> bool {
        self.load_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_params(&mut self, v: LoadParams) {
        self.load_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_load_params(&mut self) -> &mut LoadParams {
        if self.load_params.is_none() {
            self.load_params.set_default();
        }
        self.load_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_load_params(&mut self) -> LoadParams {
        self.load_params.take().unwrap_or_else(|| LoadParams::new())
    }

    // .grpc.testing.PayloadConfig payload_config = 11;


    pub fn get_payload_config(&self) -> &super::payloads::PayloadConfig {
        self.payload_config.as_ref().unwrap_or_else(|| super::payloads::PayloadConfig::default_instance())
    }
    pub fn clear_payload_config(&mut self) {
        self.payload_config.clear();
    }

    pub fn has_payload_config(&self) -> bool {
        self.payload_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload_config(&mut self, v: super::payloads::PayloadConfig) {
        self.payload_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_config(&mut self) -> &mut super::payloads::PayloadConfig {
        if self.payload_config.is_none() {
            self.payload_config.set_default();
        }
        self.payload_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload_config(&mut self) -> super::payloads::PayloadConfig {
        self.payload_config.take().unwrap_or_else(|| super::payloads::PayloadConfig::new())
    }

    // .grpc.testing.HistogramParams histogram_params = 12;


    pub fn get_histogram_params(&self) -> &super::stats::HistogramParams {
        self.histogram_params.as_ref().unwrap_or_else(|| super::stats::HistogramParams::default_instance())
    }
    pub fn clear_histogram_params(&mut self) {
        self.histogram_params.clear();
    }

    pub fn has_histogram_params(&self) -> bool {
        self.histogram_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_histogram_params(&mut self, v: super::stats::HistogramParams) {
        self.histogram_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_histogram_params(&mut self) -> &mut super::stats::HistogramParams {
        if self.histogram_params.is_none() {
            self.histogram_params.set_default();
        }
        self.histogram_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_histogram_params(&mut self) -> super::stats::HistogramParams {
        self.histogram_params.take().unwrap_or_else(|| super::stats::HistogramParams::new())
    }

    // repeated int32 core_list = 13;


    pub fn get_core_list(&self) -> &[i32] {
        &self.core_list
    }
    pub fn clear_core_list(&mut self) {
        self.core_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_core_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.core_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_core_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.core_list
    }

    // Take field
    pub fn take_core_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.core_list, ::std::vec::Vec::new())
    }

    // int32 core_limit = 14;


    pub fn get_core_limit(&self) -> i32 {
        self.core_limit
    }
    pub fn clear_core_limit(&mut self) {
        self.core_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_core_limit(&mut self, v: i32) {
        self.core_limit = v;
    }

    // string other_client_api = 15;


    pub fn get_other_client_api(&self) -> &str {
        &self.other_client_api
    }
    pub fn clear_other_client_api(&mut self) {
        self.other_client_api.clear();
    }

    // Param is passed by value, moved
    pub fn set_other_client_api(&mut self, v: ::std::string::String) {
        self.other_client_api = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_client_api(&mut self) -> &mut ::std::string::String {
        &mut self.other_client_api
    }

    // Take field
    pub fn take_other_client_api(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.other_client_api, ::std::string::String::new())
    }

    // repeated .grpc.testing.ChannelArg channel_args = 16;


    pub fn get_channel_args(&self) -> &[ChannelArg] {
        &self.channel_args
    }
    pub fn clear_channel_args(&mut self) {
        self.channel_args.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_args(&mut self, v: ::protobuf::RepeatedField<ChannelArg>) {
        self.channel_args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channel_args(&mut self) -> &mut ::protobuf::RepeatedField<ChannelArg> {
        &mut self.channel_args
    }

    // Take field
    pub fn take_channel_args(&mut self) -> ::protobuf::RepeatedField<ChannelArg> {
        ::std::mem::replace(&mut self.channel_args, ::protobuf::RepeatedField::new())
    }

    // int32 threads_per_cq = 17;


    pub fn get_threads_per_cq(&self) -> i32 {
        self.threads_per_cq
    }
    pub fn clear_threads_per_cq(&mut self) {
        self.threads_per_cq = 0;
    }

    // Param is passed by value, moved
    pub fn set_threads_per_cq(&mut self, v: i32) {
        self.threads_per_cq = v;
    }

    // int32 messages_per_stream = 18;


    pub fn get_messages_per_stream(&self) -> i32 {
        self.messages_per_stream
    }
    pub fn clear_messages_per_stream(&mut self) {
        self.messages_per_stream = 0;
    }

    // Param is passed by value, moved
    pub fn set_messages_per_stream(&mut self, v: i32) {
        self.messages_per_stream = v;
    }
}

impl ::protobuf::Message for ClientConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.security_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.load_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.payload_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.histogram_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channel_args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.server_targets)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.client_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.security_params)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.outstanding_rpcs_per_channel = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.client_channels = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.async_client_threads = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.rpc_type, 8, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.load_params)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payload_config)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.histogram_params)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.core_list)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.core_limit = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.other_client_api)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channel_args)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.threads_per_cq = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.messages_per_stream = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.server_targets {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.client_type != ClientType::SYNC_CLIENT {
            my_size += ::protobuf::rt::enum_size(2, self.client_type);
        }
        if let Some(ref v) = self.security_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.outstanding_rpcs_per_channel != 0 {
            my_size += ::protobuf::rt::value_size(4, self.outstanding_rpcs_per_channel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.client_channels != 0 {
            my_size += ::protobuf::rt::value_size(5, self.client_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.async_client_threads != 0 {
            my_size += ::protobuf::rt::value_size(7, self.async_client_threads, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rpc_type != RpcType::UNARY {
            my_size += ::protobuf::rt::enum_size(8, self.rpc_type);
        }
        if let Some(ref v) = self.load_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.payload_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.histogram_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.core_list {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.core_limit != 0 {
            my_size += ::protobuf::rt::value_size(14, self.core_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.other_client_api.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.other_client_api);
        }
        for value in &self.channel_args {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.threads_per_cq != 0 {
            my_size += ::protobuf::rt::value_size(17, self.threads_per_cq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.messages_per_stream != 0 {
            my_size += ::protobuf::rt::value_size(18, self.messages_per_stream, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.server_targets {
            os.write_string(1, &v)?;
        };
        if self.client_type != ClientType::SYNC_CLIENT {
            os.write_enum(2, self.client_type.value())?;
        }
        if let Some(ref v) = self.security_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.outstanding_rpcs_per_channel != 0 {
            os.write_int32(4, self.outstanding_rpcs_per_channel)?;
        }
        if self.client_channels != 0 {
            os.write_int32(5, self.client_channels)?;
        }
        if self.async_client_threads != 0 {
            os.write_int32(7, self.async_client_threads)?;
        }
        if self.rpc_type != RpcType::UNARY {
            os.write_enum(8, self.rpc_type.value())?;
        }
        if let Some(ref v) = self.load_params.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.payload_config.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.histogram_params.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.core_list {
            os.write_int32(13, *v)?;
        };
        if self.core_limit != 0 {
            os.write_int32(14, self.core_limit)?;
        }
        if !self.other_client_api.is_empty() {
            os.write_string(15, &self.other_client_api)?;
        }
        for v in &self.channel_args {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.threads_per_cq != 0 {
            os.write_int32(17, self.threads_per_cq)?;
        }
        if self.messages_per_stream != 0 {
            os.write_int32(18, self.messages_per_stream)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientConfig {
        ClientConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "server_targets",
                    |m: &ClientConfig| { &m.server_targets },
                    |m: &mut ClientConfig| { &mut m.server_targets },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClientType>>(
                    "client_type",
                    |m: &ClientConfig| { &m.client_type },
                    |m: &mut ClientConfig| { &mut m.client_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurityParams>>(
                    "security_params",
                    |m: &ClientConfig| { &m.security_params },
                    |m: &mut ClientConfig| { &mut m.security_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "outstanding_rpcs_per_channel",
                    |m: &ClientConfig| { &m.outstanding_rpcs_per_channel },
                    |m: &mut ClientConfig| { &mut m.outstanding_rpcs_per_channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "client_channels",
                    |m: &ClientConfig| { &m.client_channels },
                    |m: &mut ClientConfig| { &mut m.client_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "async_client_threads",
                    |m: &ClientConfig| { &m.async_client_threads },
                    |m: &mut ClientConfig| { &mut m.async_client_threads },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RpcType>>(
                    "rpc_type",
                    |m: &ClientConfig| { &m.rpc_type },
                    |m: &mut ClientConfig| { &mut m.rpc_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadParams>>(
                    "load_params",
                    |m: &ClientConfig| { &m.load_params },
                    |m: &mut ClientConfig| { &mut m.load_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::payloads::PayloadConfig>>(
                    "payload_config",
                    |m: &ClientConfig| { &m.payload_config },
                    |m: &mut ClientConfig| { &mut m.payload_config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::stats::HistogramParams>>(
                    "histogram_params",
                    |m: &ClientConfig| { &m.histogram_params },
                    |m: &mut ClientConfig| { &mut m.histogram_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "core_list",
                    |m: &ClientConfig| { &m.core_list },
                    |m: &mut ClientConfig| { &mut m.core_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "core_limit",
                    |m: &ClientConfig| { &m.core_limit },
                    |m: &mut ClientConfig| { &mut m.core_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "other_client_api",
                    |m: &ClientConfig| { &m.other_client_api },
                    |m: &mut ClientConfig| { &mut m.other_client_api },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelArg>>(
                    "channel_args",
                    |m: &ClientConfig| { &m.channel_args },
                    |m: &mut ClientConfig| { &mut m.channel_args },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "threads_per_cq",
                    |m: &ClientConfig| { &m.threads_per_cq },
                    |m: &mut ClientConfig| { &mut m.threads_per_cq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "messages_per_stream",
                    |m: &ClientConfig| { &m.messages_per_stream },
                    |m: &mut ClientConfig| { &mut m.messages_per_stream },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClientConfig>(
                    "ClientConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClientConfig {
        static mut instance: ::protobuf::lazy::Lazy<ClientConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClientConfig,
        };
        unsafe {
            instance.get(ClientConfig::new)
        }
    }
}

impl ::protobuf::Clear for ClientConfig {
    fn clear(&mut self) {
        self.server_targets.clear();
        self.client_type = ClientType::SYNC_CLIENT;
        self.security_params.clear();
        self.outstanding_rpcs_per_channel = 0;
        self.client_channels = 0;
        self.async_client_threads = 0;
        self.rpc_type = RpcType::UNARY;
        self.load_params.clear();
        self.payload_config.clear();
        self.histogram_params.clear();
        self.core_list.clear();
        self.core_limit = 0;
        self.other_client_api.clear();
        self.channel_args.clear();
        self.threads_per_cq = 0;
        self.messages_per_stream = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientStatus {
    // message fields
    pub stats: ::protobuf::SingularPtrField<super::stats::ClientStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientStatus {
    fn default() -> &'a ClientStatus {
        <ClientStatus as ::protobuf::Message>::default_instance()
    }
}

impl ClientStatus {
    pub fn new() -> ClientStatus {
        ::std::default::Default::default()
    }

    // .grpc.testing.ClientStats stats = 1;


    pub fn get_stats(&self) -> &super::stats::ClientStats {
        self.stats.as_ref().unwrap_or_else(|| super::stats::ClientStats::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: super::stats::ClientStats) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut super::stats::ClientStats {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> super::stats::ClientStats {
        self.stats.take().unwrap_or_else(|| super::stats::ClientStats::new())
    }
}

impl ::protobuf::Message for ClientStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientStatus {
        ClientStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::stats::ClientStats>>(
                    "stats",
                    |m: &ClientStatus| { &m.stats },
                    |m: &mut ClientStatus| { &mut m.stats },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClientStatus>(
                    "ClientStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClientStatus {
        static mut instance: ::protobuf::lazy::Lazy<ClientStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClientStatus,
        };
        unsafe {
            instance.get(ClientStatus::new)
        }
    }
}

impl ::protobuf::Clear for ClientStatus {
    fn clear(&mut self) {
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mark {
    // message fields
    pub reset: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mark {
    fn default() -> &'a Mark {
        <Mark as ::protobuf::Message>::default_instance()
    }
}

impl Mark {
    pub fn new() -> Mark {
        ::std::default::Default::default()
    }

    // bool reset = 1;


    pub fn get_reset(&self) -> bool {
        self.reset
    }
    pub fn clear_reset(&mut self) {
        self.reset = false;
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: bool) {
        self.reset = v;
    }
}

impl ::protobuf::Message for Mark {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.reset != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.reset != false {
            os.write_bool(1, self.reset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mark {
        Mark::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reset",
                    |m: &Mark| { &m.reset },
                    |m: &mut Mark| { &mut m.reset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Mark>(
                    "Mark",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Mark {
        static mut instance: ::protobuf::lazy::Lazy<Mark> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Mark,
        };
        unsafe {
            instance.get(Mark::new)
        }
    }
}

impl ::protobuf::Clear for Mark {
    fn clear(&mut self) {
        self.reset = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mark {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mark {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientArgs {
    // message oneof groups
    pub argtype: ::std::option::Option<ClientArgs_oneof_argtype>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientArgs {
    fn default() -> &'a ClientArgs {
        <ClientArgs as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ClientArgs_oneof_argtype {
    setup(ClientConfig),
    mark(Mark),
}

impl ClientArgs {
    pub fn new() -> ClientArgs {
        ::std::default::Default::default()
    }

    // .grpc.testing.ClientConfig setup = 1;


    pub fn get_setup(&self) -> &ClientConfig {
        match self.argtype {
            ::std::option::Option::Some(ClientArgs_oneof_argtype::setup(ref v)) => v,
            _ => ClientConfig::default_instance(),
        }
    }
    pub fn clear_setup(&mut self) {
        self.argtype = ::std::option::Option::None;
    }

    pub fn has_setup(&self) -> bool {
        match self.argtype {
            ::std::option::Option::Some(ClientArgs_oneof_argtype::setup(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setup(&mut self, v: ClientConfig) {
        self.argtype = ::std::option::Option::Some(ClientArgs_oneof_argtype::setup(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setup(&mut self) -> &mut ClientConfig {
        if let ::std::option::Option::Some(ClientArgs_oneof_argtype::setup(_)) = self.argtype {
        } else {
            self.argtype = ::std::option::Option::Some(ClientArgs_oneof_argtype::setup(ClientConfig::new()));
        }
        match self.argtype {
            ::std::option::Option::Some(ClientArgs_oneof_argtype::setup(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setup(&mut self) -> ClientConfig {
        if self.has_setup() {
            match self.argtype.take() {
                ::std::option::Option::Some(ClientArgs_oneof_argtype::setup(v)) => v,
                _ => panic!(),
            }
        } else {
            ClientConfig::new()
        }
    }

    // .grpc.testing.Mark mark = 2;


    pub fn get_mark(&self) -> &Mark {
        match self.argtype {
            ::std::option::Option::Some(ClientArgs_oneof_argtype::mark(ref v)) => v,
            _ => Mark::default_instance(),
        }
    }
    pub fn clear_mark(&mut self) {
        self.argtype = ::std::option::Option::None;
    }

    pub fn has_mark(&self) -> bool {
        match self.argtype {
            ::std::option::Option::Some(ClientArgs_oneof_argtype::mark(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mark(&mut self, v: Mark) {
        self.argtype = ::std::option::Option::Some(ClientArgs_oneof_argtype::mark(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mark(&mut self) -> &mut Mark {
        if let ::std::option::Option::Some(ClientArgs_oneof_argtype::mark(_)) = self.argtype {
        } else {
            self.argtype = ::std::option::Option::Some(ClientArgs_oneof_argtype::mark(Mark::new()));
        }
        match self.argtype {
            ::std::option::Option::Some(ClientArgs_oneof_argtype::mark(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mark(&mut self) -> Mark {
        if self.has_mark() {
            match self.argtype.take() {
                ::std::option::Option::Some(ClientArgs_oneof_argtype::mark(v)) => v,
                _ => panic!(),
            }
        } else {
            Mark::new()
        }
    }
}

impl ::protobuf::Message for ClientArgs {
    fn is_initialized(&self) -> bool {
        if let Some(ClientArgs_oneof_argtype::setup(ref v)) = self.argtype {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ClientArgs_oneof_argtype::mark(ref v)) = self.argtype {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.argtype = ::std::option::Option::Some(ClientArgs_oneof_argtype::setup(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.argtype = ::std::option::Option::Some(ClientArgs_oneof_argtype::mark(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.argtype {
            match v {
                &ClientArgs_oneof_argtype::setup(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ClientArgs_oneof_argtype::mark(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.argtype {
            match v {
                &ClientArgs_oneof_argtype::setup(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ClientArgs_oneof_argtype::mark(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientArgs {
        ClientArgs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ClientConfig>(
                    "setup",
                    ClientArgs::has_setup,
                    ClientArgs::get_setup,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Mark>(
                    "mark",
                    ClientArgs::has_mark,
                    ClientArgs::get_mark,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClientArgs>(
                    "ClientArgs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClientArgs {
        static mut instance: ::protobuf::lazy::Lazy<ClientArgs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClientArgs,
        };
        unsafe {
            instance.get(ClientArgs::new)
        }
    }
}

impl ::protobuf::Clear for ClientArgs {
    fn clear(&mut self) {
        self.argtype = ::std::option::Option::None;
        self.argtype = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientArgs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientArgs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerConfig {
    // message fields
    pub server_type: ServerType,
    pub security_params: ::protobuf::SingularPtrField<SecurityParams>,
    pub port: i32,
    pub async_server_threads: i32,
    pub core_limit: i32,
    pub payload_config: ::protobuf::SingularPtrField<super::payloads::PayloadConfig>,
    pub core_list: ::std::vec::Vec<i32>,
    pub other_server_api: ::std::string::String,
    pub threads_per_cq: i32,
    pub resource_quota_size: i32,
    pub channel_args: ::protobuf::RepeatedField<ChannelArg>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerConfig {
    fn default() -> &'a ServerConfig {
        <ServerConfig as ::protobuf::Message>::default_instance()
    }
}

impl ServerConfig {
    pub fn new() -> ServerConfig {
        ::std::default::Default::default()
    }

    // .grpc.testing.ServerType server_type = 1;


    pub fn get_server_type(&self) -> ServerType {
        self.server_type
    }
    pub fn clear_server_type(&mut self) {
        self.server_type = ServerType::SYNC_SERVER;
    }

    // Param is passed by value, moved
    pub fn set_server_type(&mut self, v: ServerType) {
        self.server_type = v;
    }

    // .grpc.testing.SecurityParams security_params = 2;


    pub fn get_security_params(&self) -> &SecurityParams {
        self.security_params.as_ref().unwrap_or_else(|| SecurityParams::default_instance())
    }
    pub fn clear_security_params(&mut self) {
        self.security_params.clear();
    }

    pub fn has_security_params(&self) -> bool {
        self.security_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_security_params(&mut self, v: SecurityParams) {
        self.security_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security_params(&mut self) -> &mut SecurityParams {
        if self.security_params.is_none() {
            self.security_params.set_default();
        }
        self.security_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_security_params(&mut self) -> SecurityParams {
        self.security_params.take().unwrap_or_else(|| SecurityParams::new())
    }

    // int32 port = 4;


    pub fn get_port(&self) -> i32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }

    // int32 async_server_threads = 7;


    pub fn get_async_server_threads(&self) -> i32 {
        self.async_server_threads
    }
    pub fn clear_async_server_threads(&mut self) {
        self.async_server_threads = 0;
    }

    // Param is passed by value, moved
    pub fn set_async_server_threads(&mut self, v: i32) {
        self.async_server_threads = v;
    }

    // int32 core_limit = 8;


    pub fn get_core_limit(&self) -> i32 {
        self.core_limit
    }
    pub fn clear_core_limit(&mut self) {
        self.core_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_core_limit(&mut self, v: i32) {
        self.core_limit = v;
    }

    // .grpc.testing.PayloadConfig payload_config = 9;


    pub fn get_payload_config(&self) -> &super::payloads::PayloadConfig {
        self.payload_config.as_ref().unwrap_or_else(|| super::payloads::PayloadConfig::default_instance())
    }
    pub fn clear_payload_config(&mut self) {
        self.payload_config.clear();
    }

    pub fn has_payload_config(&self) -> bool {
        self.payload_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload_config(&mut self, v: super::payloads::PayloadConfig) {
        self.payload_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_config(&mut self) -> &mut super::payloads::PayloadConfig {
        if self.payload_config.is_none() {
            self.payload_config.set_default();
        }
        self.payload_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload_config(&mut self) -> super::payloads::PayloadConfig {
        self.payload_config.take().unwrap_or_else(|| super::payloads::PayloadConfig::new())
    }

    // repeated int32 core_list = 10;


    pub fn get_core_list(&self) -> &[i32] {
        &self.core_list
    }
    pub fn clear_core_list(&mut self) {
        self.core_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_core_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.core_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_core_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.core_list
    }

    // Take field
    pub fn take_core_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.core_list, ::std::vec::Vec::new())
    }

    // string other_server_api = 11;


    pub fn get_other_server_api(&self) -> &str {
        &self.other_server_api
    }
    pub fn clear_other_server_api(&mut self) {
        self.other_server_api.clear();
    }

    // Param is passed by value, moved
    pub fn set_other_server_api(&mut self, v: ::std::string::String) {
        self.other_server_api = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_server_api(&mut self) -> &mut ::std::string::String {
        &mut self.other_server_api
    }

    // Take field
    pub fn take_other_server_api(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.other_server_api, ::std::string::String::new())
    }

    // int32 threads_per_cq = 12;


    pub fn get_threads_per_cq(&self) -> i32 {
        self.threads_per_cq
    }
    pub fn clear_threads_per_cq(&mut self) {
        self.threads_per_cq = 0;
    }

    // Param is passed by value, moved
    pub fn set_threads_per_cq(&mut self, v: i32) {
        self.threads_per_cq = v;
    }

    // int32 resource_quota_size = 1001;


    pub fn get_resource_quota_size(&self) -> i32 {
        self.resource_quota_size
    }
    pub fn clear_resource_quota_size(&mut self) {
        self.resource_quota_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_resource_quota_size(&mut self, v: i32) {
        self.resource_quota_size = v;
    }

    // repeated .grpc.testing.ChannelArg channel_args = 1002;


    pub fn get_channel_args(&self) -> &[ChannelArg] {
        &self.channel_args
    }
    pub fn clear_channel_args(&mut self) {
        self.channel_args.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_args(&mut self, v: ::protobuf::RepeatedField<ChannelArg>) {
        self.channel_args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channel_args(&mut self) -> &mut ::protobuf::RepeatedField<ChannelArg> {
        &mut self.channel_args
    }

    // Take field
    pub fn take_channel_args(&mut self) -> ::protobuf::RepeatedField<ChannelArg> {
        ::std::mem::replace(&mut self.channel_args, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ServerConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.security_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.payload_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channel_args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.server_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.security_params)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.async_server_threads = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.core_limit = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payload_config)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.core_list)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.other_server_api)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.threads_per_cq = tmp;
                },
                1001 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.resource_quota_size = tmp;
                },
                1002 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channel_args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.server_type != ServerType::SYNC_SERVER {
            my_size += ::protobuf::rt::enum_size(1, self.server_type);
        }
        if let Some(ref v) = self.security_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(4, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.async_server_threads != 0 {
            my_size += ::protobuf::rt::value_size(7, self.async_server_threads, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.core_limit != 0 {
            my_size += ::protobuf::rt::value_size(8, self.core_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.payload_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.core_list {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.other_server_api.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.other_server_api);
        }
        if self.threads_per_cq != 0 {
            my_size += ::protobuf::rt::value_size(12, self.threads_per_cq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.resource_quota_size != 0 {
            my_size += ::protobuf::rt::value_size(1001, self.resource_quota_size, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.channel_args {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.server_type != ServerType::SYNC_SERVER {
            os.write_enum(1, self.server_type.value())?;
        }
        if let Some(ref v) = self.security_params.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.port != 0 {
            os.write_int32(4, self.port)?;
        }
        if self.async_server_threads != 0 {
            os.write_int32(7, self.async_server_threads)?;
        }
        if self.core_limit != 0 {
            os.write_int32(8, self.core_limit)?;
        }
        if let Some(ref v) = self.payload_config.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.core_list {
            os.write_int32(10, *v)?;
        };
        if !self.other_server_api.is_empty() {
            os.write_string(11, &self.other_server_api)?;
        }
        if self.threads_per_cq != 0 {
            os.write_int32(12, self.threads_per_cq)?;
        }
        if self.resource_quota_size != 0 {
            os.write_int32(1001, self.resource_quota_size)?;
        }
        for v in &self.channel_args {
            os.write_tag(1002, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerConfig {
        ServerConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServerType>>(
                    "server_type",
                    |m: &ServerConfig| { &m.server_type },
                    |m: &mut ServerConfig| { &mut m.server_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurityParams>>(
                    "security_params",
                    |m: &ServerConfig| { &m.security_params },
                    |m: &mut ServerConfig| { &mut m.security_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "port",
                    |m: &ServerConfig| { &m.port },
                    |m: &mut ServerConfig| { &mut m.port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "async_server_threads",
                    |m: &ServerConfig| { &m.async_server_threads },
                    |m: &mut ServerConfig| { &mut m.async_server_threads },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "core_limit",
                    |m: &ServerConfig| { &m.core_limit },
                    |m: &mut ServerConfig| { &mut m.core_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::payloads::PayloadConfig>>(
                    "payload_config",
                    |m: &ServerConfig| { &m.payload_config },
                    |m: &mut ServerConfig| { &mut m.payload_config },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "core_list",
                    |m: &ServerConfig| { &m.core_list },
                    |m: &mut ServerConfig| { &mut m.core_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "other_server_api",
                    |m: &ServerConfig| { &m.other_server_api },
                    |m: &mut ServerConfig| { &mut m.other_server_api },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "threads_per_cq",
                    |m: &ServerConfig| { &m.threads_per_cq },
                    |m: &mut ServerConfig| { &mut m.threads_per_cq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "resource_quota_size",
                    |m: &ServerConfig| { &m.resource_quota_size },
                    |m: &mut ServerConfig| { &mut m.resource_quota_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelArg>>(
                    "channel_args",
                    |m: &ServerConfig| { &m.channel_args },
                    |m: &mut ServerConfig| { &mut m.channel_args },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServerConfig>(
                    "ServerConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServerConfig {
        static mut instance: ::protobuf::lazy::Lazy<ServerConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerConfig,
        };
        unsafe {
            instance.get(ServerConfig::new)
        }
    }
}

impl ::protobuf::Clear for ServerConfig {
    fn clear(&mut self) {
        self.server_type = ServerType::SYNC_SERVER;
        self.security_params.clear();
        self.port = 0;
        self.async_server_threads = 0;
        self.core_limit = 0;
        self.payload_config.clear();
        self.core_list.clear();
        self.other_server_api.clear();
        self.threads_per_cq = 0;
        self.resource_quota_size = 0;
        self.channel_args.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerArgs {
    // message oneof groups
    pub argtype: ::std::option::Option<ServerArgs_oneof_argtype>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerArgs {
    fn default() -> &'a ServerArgs {
        <ServerArgs as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ServerArgs_oneof_argtype {
    setup(ServerConfig),
    mark(Mark),
}

impl ServerArgs {
    pub fn new() -> ServerArgs {
        ::std::default::Default::default()
    }

    // .grpc.testing.ServerConfig setup = 1;


    pub fn get_setup(&self) -> &ServerConfig {
        match self.argtype {
            ::std::option::Option::Some(ServerArgs_oneof_argtype::setup(ref v)) => v,
            _ => ServerConfig::default_instance(),
        }
    }
    pub fn clear_setup(&mut self) {
        self.argtype = ::std::option::Option::None;
    }

    pub fn has_setup(&self) -> bool {
        match self.argtype {
            ::std::option::Option::Some(ServerArgs_oneof_argtype::setup(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setup(&mut self, v: ServerConfig) {
        self.argtype = ::std::option::Option::Some(ServerArgs_oneof_argtype::setup(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setup(&mut self) -> &mut ServerConfig {
        if let ::std::option::Option::Some(ServerArgs_oneof_argtype::setup(_)) = self.argtype {
        } else {
            self.argtype = ::std::option::Option::Some(ServerArgs_oneof_argtype::setup(ServerConfig::new()));
        }
        match self.argtype {
            ::std::option::Option::Some(ServerArgs_oneof_argtype::setup(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setup(&mut self) -> ServerConfig {
        if self.has_setup() {
            match self.argtype.take() {
                ::std::option::Option::Some(ServerArgs_oneof_argtype::setup(v)) => v,
                _ => panic!(),
            }
        } else {
            ServerConfig::new()
        }
    }

    // .grpc.testing.Mark mark = 2;


    pub fn get_mark(&self) -> &Mark {
        match self.argtype {
            ::std::option::Option::Some(ServerArgs_oneof_argtype::mark(ref v)) => v,
            _ => Mark::default_instance(),
        }
    }
    pub fn clear_mark(&mut self) {
        self.argtype = ::std::option::Option::None;
    }

    pub fn has_mark(&self) -> bool {
        match self.argtype {
            ::std::option::Option::Some(ServerArgs_oneof_argtype::mark(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mark(&mut self, v: Mark) {
        self.argtype = ::std::option::Option::Some(ServerArgs_oneof_argtype::mark(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mark(&mut self) -> &mut Mark {
        if let ::std::option::Option::Some(ServerArgs_oneof_argtype::mark(_)) = self.argtype {
        } else {
            self.argtype = ::std::option::Option::Some(ServerArgs_oneof_argtype::mark(Mark::new()));
        }
        match self.argtype {
            ::std::option::Option::Some(ServerArgs_oneof_argtype::mark(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mark(&mut self) -> Mark {
        if self.has_mark() {
            match self.argtype.take() {
                ::std::option::Option::Some(ServerArgs_oneof_argtype::mark(v)) => v,
                _ => panic!(),
            }
        } else {
            Mark::new()
        }
    }
}

impl ::protobuf::Message for ServerArgs {
    fn is_initialized(&self) -> bool {
        if let Some(ServerArgs_oneof_argtype::setup(ref v)) = self.argtype {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ServerArgs_oneof_argtype::mark(ref v)) = self.argtype {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.argtype = ::std::option::Option::Some(ServerArgs_oneof_argtype::setup(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.argtype = ::std::option::Option::Some(ServerArgs_oneof_argtype::mark(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.argtype {
            match v {
                &ServerArgs_oneof_argtype::setup(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ServerArgs_oneof_argtype::mark(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.argtype {
            match v {
                &ServerArgs_oneof_argtype::setup(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ServerArgs_oneof_argtype::mark(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerArgs {
        ServerArgs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ServerConfig>(
                    "setup",
                    ServerArgs::has_setup,
                    ServerArgs::get_setup,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Mark>(
                    "mark",
                    ServerArgs::has_mark,
                    ServerArgs::get_mark,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServerArgs>(
                    "ServerArgs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServerArgs {
        static mut instance: ::protobuf::lazy::Lazy<ServerArgs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerArgs,
        };
        unsafe {
            instance.get(ServerArgs::new)
        }
    }
}

impl ::protobuf::Clear for ServerArgs {
    fn clear(&mut self) {
        self.argtype = ::std::option::Option::None;
        self.argtype = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerArgs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerArgs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerStatus {
    // message fields
    pub stats: ::protobuf::SingularPtrField<super::stats::ServerStats>,
    pub port: i32,
    pub cores: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerStatus {
    fn default() -> &'a ServerStatus {
        <ServerStatus as ::protobuf::Message>::default_instance()
    }
}

impl ServerStatus {
    pub fn new() -> ServerStatus {
        ::std::default::Default::default()
    }

    // .grpc.testing.ServerStats stats = 1;


    pub fn get_stats(&self) -> &super::stats::ServerStats {
        self.stats.as_ref().unwrap_or_else(|| super::stats::ServerStats::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: super::stats::ServerStats) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut super::stats::ServerStats {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> super::stats::ServerStats {
        self.stats.take().unwrap_or_else(|| super::stats::ServerStats::new())
    }

    // int32 port = 2;


    pub fn get_port(&self) -> i32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }

    // int32 cores = 3;


    pub fn get_cores(&self) -> i32 {
        self.cores
    }
    pub fn clear_cores(&mut self) {
        self.cores = 0;
    }

    // Param is passed by value, moved
    pub fn set_cores(&mut self, v: i32) {
        self.cores = v;
    }
}

impl ::protobuf::Message for ServerStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cores = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cores != 0 {
            my_size += ::protobuf::rt::value_size(3, self.cores, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        if self.cores != 0 {
            os.write_int32(3, self.cores)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerStatus {
        ServerStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::stats::ServerStats>>(
                    "stats",
                    |m: &ServerStatus| { &m.stats },
                    |m: &mut ServerStatus| { &mut m.stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "port",
                    |m: &ServerStatus| { &m.port },
                    |m: &mut ServerStatus| { &mut m.port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "cores",
                    |m: &ServerStatus| { &m.cores },
                    |m: &mut ServerStatus| { &mut m.cores },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServerStatus>(
                    "ServerStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServerStatus {
        static mut instance: ::protobuf::lazy::Lazy<ServerStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerStatus,
        };
        unsafe {
            instance.get(ServerStatus::new)
        }
    }
}

impl ::protobuf::Clear for ServerStatus {
    fn clear(&mut self) {
        self.stats.clear();
        self.port = 0;
        self.cores = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CoreRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoreRequest {
    fn default() -> &'a CoreRequest {
        <CoreRequest as ::protobuf::Message>::default_instance()
    }
}

impl CoreRequest {
    pub fn new() -> CoreRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CoreRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoreRequest {
        CoreRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CoreRequest>(
                    "CoreRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CoreRequest {
        static mut instance: ::protobuf::lazy::Lazy<CoreRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CoreRequest,
        };
        unsafe {
            instance.get(CoreRequest::new)
        }
    }
}

impl ::protobuf::Clear for CoreRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoreRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CoreResponse {
    // message fields
    pub cores: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoreResponse {
    fn default() -> &'a CoreResponse {
        <CoreResponse as ::protobuf::Message>::default_instance()
    }
}

impl CoreResponse {
    pub fn new() -> CoreResponse {
        ::std::default::Default::default()
    }

    // int32 cores = 1;


    pub fn get_cores(&self) -> i32 {
        self.cores
    }
    pub fn clear_cores(&mut self) {
        self.cores = 0;
    }

    // Param is passed by value, moved
    pub fn set_cores(&mut self, v: i32) {
        self.cores = v;
    }
}

impl ::protobuf::Message for CoreResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cores = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cores != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cores, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cores != 0 {
            os.write_int32(1, self.cores)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoreResponse {
        CoreResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "cores",
                    |m: &CoreResponse| { &m.cores },
                    |m: &mut CoreResponse| { &mut m.cores },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CoreResponse>(
                    "CoreResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CoreResponse {
        static mut instance: ::protobuf::lazy::Lazy<CoreResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CoreResponse,
        };
        unsafe {
            instance.get(CoreResponse::new)
        }
    }
}

impl ::protobuf::Clear for CoreResponse {
    fn clear(&mut self) {
        self.cores = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoreResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Void {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Void {
    fn default() -> &'a Void {
        <Void as ::protobuf::Message>::default_instance()
    }
}

impl Void {
    pub fn new() -> Void {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Void {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Void {
        Void::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Void>(
                    "Void",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Void {
        static mut instance: ::protobuf::lazy::Lazy<Void> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Void,
        };
        unsafe {
            instance.get(Void::new)
        }
    }
}

impl ::protobuf::Clear for Void {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Void {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Void {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Scenario {
    // message fields
    pub name: ::std::string::String,
    pub client_config: ::protobuf::SingularPtrField<ClientConfig>,
    pub num_clients: i32,
    pub server_config: ::protobuf::SingularPtrField<ServerConfig>,
    pub num_servers: i32,
    pub warmup_seconds: i32,
    pub benchmark_seconds: i32,
    pub spawn_local_worker_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Scenario {
    fn default() -> &'a Scenario {
        <Scenario as ::protobuf::Message>::default_instance()
    }
}

impl Scenario {
    pub fn new() -> Scenario {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .grpc.testing.ClientConfig client_config = 2;


    pub fn get_client_config(&self) -> &ClientConfig {
        self.client_config.as_ref().unwrap_or_else(|| ClientConfig::default_instance())
    }
    pub fn clear_client_config(&mut self) {
        self.client_config.clear();
    }

    pub fn has_client_config(&self) -> bool {
        self.client_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_config(&mut self, v: ClientConfig) {
        self.client_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_config(&mut self) -> &mut ClientConfig {
        if self.client_config.is_none() {
            self.client_config.set_default();
        }
        self.client_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_config(&mut self) -> ClientConfig {
        self.client_config.take().unwrap_or_else(|| ClientConfig::new())
    }

    // int32 num_clients = 3;


    pub fn get_num_clients(&self) -> i32 {
        self.num_clients
    }
    pub fn clear_num_clients(&mut self) {
        self.num_clients = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_clients(&mut self, v: i32) {
        self.num_clients = v;
    }

    // .grpc.testing.ServerConfig server_config = 4;


    pub fn get_server_config(&self) -> &ServerConfig {
        self.server_config.as_ref().unwrap_or_else(|| ServerConfig::default_instance())
    }
    pub fn clear_server_config(&mut self) {
        self.server_config.clear();
    }

    pub fn has_server_config(&self) -> bool {
        self.server_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_config(&mut self, v: ServerConfig) {
        self.server_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_config(&mut self) -> &mut ServerConfig {
        if self.server_config.is_none() {
            self.server_config.set_default();
        }
        self.server_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_config(&mut self) -> ServerConfig {
        self.server_config.take().unwrap_or_else(|| ServerConfig::new())
    }

    // int32 num_servers = 5;


    pub fn get_num_servers(&self) -> i32 {
        self.num_servers
    }
    pub fn clear_num_servers(&mut self) {
        self.num_servers = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_servers(&mut self, v: i32) {
        self.num_servers = v;
    }

    // int32 warmup_seconds = 6;


    pub fn get_warmup_seconds(&self) -> i32 {
        self.warmup_seconds
    }
    pub fn clear_warmup_seconds(&mut self) {
        self.warmup_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_warmup_seconds(&mut self, v: i32) {
        self.warmup_seconds = v;
    }

    // int32 benchmark_seconds = 7;


    pub fn get_benchmark_seconds(&self) -> i32 {
        self.benchmark_seconds
    }
    pub fn clear_benchmark_seconds(&mut self) {
        self.benchmark_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_benchmark_seconds(&mut self, v: i32) {
        self.benchmark_seconds = v;
    }

    // int32 spawn_local_worker_count = 8;


    pub fn get_spawn_local_worker_count(&self) -> i32 {
        self.spawn_local_worker_count
    }
    pub fn clear_spawn_local_worker_count(&mut self) {
        self.spawn_local_worker_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_spawn_local_worker_count(&mut self, v: i32) {
        self.spawn_local_worker_count = v;
    }
}

impl ::protobuf::Message for Scenario {
    fn is_initialized(&self) -> bool {
        for v in &self.client_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.server_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.client_config)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_clients = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_config)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_servers = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.warmup_seconds = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.benchmark_seconds = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.spawn_local_worker_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.client_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.num_clients != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_clients, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.server_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.num_servers != 0 {
            my_size += ::protobuf::rt::value_size(5, self.num_servers, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.warmup_seconds != 0 {
            my_size += ::protobuf::rt::value_size(6, self.warmup_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.benchmark_seconds != 0 {
            my_size += ::protobuf::rt::value_size(7, self.benchmark_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.spawn_local_worker_count != 0 {
            my_size += ::protobuf::rt::value_size(8, self.spawn_local_worker_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.client_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.num_clients != 0 {
            os.write_int32(3, self.num_clients)?;
        }
        if let Some(ref v) = self.server_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.num_servers != 0 {
            os.write_int32(5, self.num_servers)?;
        }
        if self.warmup_seconds != 0 {
            os.write_int32(6, self.warmup_seconds)?;
        }
        if self.benchmark_seconds != 0 {
            os.write_int32(7, self.benchmark_seconds)?;
        }
        if self.spawn_local_worker_count != 0 {
            os.write_int32(8, self.spawn_local_worker_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Scenario {
        Scenario::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Scenario| { &m.name },
                    |m: &mut Scenario| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientConfig>>(
                    "client_config",
                    |m: &Scenario| { &m.client_config },
                    |m: &mut Scenario| { &mut m.client_config },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_clients",
                    |m: &Scenario| { &m.num_clients },
                    |m: &mut Scenario| { &mut m.num_clients },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerConfig>>(
                    "server_config",
                    |m: &Scenario| { &m.server_config },
                    |m: &mut Scenario| { &mut m.server_config },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_servers",
                    |m: &Scenario| { &m.num_servers },
                    |m: &mut Scenario| { &mut m.num_servers },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "warmup_seconds",
                    |m: &Scenario| { &m.warmup_seconds },
                    |m: &mut Scenario| { &mut m.warmup_seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "benchmark_seconds",
                    |m: &Scenario| { &m.benchmark_seconds },
                    |m: &mut Scenario| { &mut m.benchmark_seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "spawn_local_worker_count",
                    |m: &Scenario| { &m.spawn_local_worker_count },
                    |m: &mut Scenario| { &mut m.spawn_local_worker_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Scenario>(
                    "Scenario",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Scenario {
        static mut instance: ::protobuf::lazy::Lazy<Scenario> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Scenario,
        };
        unsafe {
            instance.get(Scenario::new)
        }
    }
}

impl ::protobuf::Clear for Scenario {
    fn clear(&mut self) {
        self.name.clear();
        self.client_config.clear();
        self.num_clients = 0;
        self.server_config.clear();
        self.num_servers = 0;
        self.warmup_seconds = 0;
        self.benchmark_seconds = 0;
        self.spawn_local_worker_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Scenario {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Scenario {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Scenarios {
    // message fields
    pub scenarios: ::protobuf::RepeatedField<Scenario>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Scenarios {
    fn default() -> &'a Scenarios {
        <Scenarios as ::protobuf::Message>::default_instance()
    }
}

impl Scenarios {
    pub fn new() -> Scenarios {
        ::std::default::Default::default()
    }

    // repeated .grpc.testing.Scenario scenarios = 1;


    pub fn get_scenarios(&self) -> &[Scenario] {
        &self.scenarios
    }
    pub fn clear_scenarios(&mut self) {
        self.scenarios.clear();
    }

    // Param is passed by value, moved
    pub fn set_scenarios(&mut self, v: ::protobuf::RepeatedField<Scenario>) {
        self.scenarios = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scenarios(&mut self) -> &mut ::protobuf::RepeatedField<Scenario> {
        &mut self.scenarios
    }

    // Take field
    pub fn take_scenarios(&mut self) -> ::protobuf::RepeatedField<Scenario> {
        ::std::mem::replace(&mut self.scenarios, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Scenarios {
    fn is_initialized(&self) -> bool {
        for v in &self.scenarios {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.scenarios)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.scenarios {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.scenarios {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Scenarios {
        Scenarios::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Scenario>>(
                    "scenarios",
                    |m: &Scenarios| { &m.scenarios },
                    |m: &mut Scenarios| { &mut m.scenarios },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Scenarios>(
                    "Scenarios",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Scenarios {
        static mut instance: ::protobuf::lazy::Lazy<Scenarios> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Scenarios,
        };
        unsafe {
            instance.get(Scenarios::new)
        }
    }
}

impl ::protobuf::Clear for Scenarios {
    fn clear(&mut self) {
        self.scenarios.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Scenarios {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Scenarios {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScenarioResultSummary {
    // message fields
    pub qps: f64,
    pub qps_per_server_core: f64,
    pub server_system_time: f64,
    pub server_user_time: f64,
    pub client_system_time: f64,
    pub client_user_time: f64,
    pub latency_50: f64,
    pub latency_90: f64,
    pub latency_95: f64,
    pub latency_99: f64,
    pub latency_999: f64,
    pub server_cpu_usage: f64,
    pub successful_requests_per_second: f64,
    pub failed_requests_per_second: f64,
    pub client_polls_per_request: f64,
    pub server_polls_per_request: f64,
    pub server_queries_per_cpu_sec: f64,
    pub client_queries_per_cpu_sec: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScenarioResultSummary {
    fn default() -> &'a ScenarioResultSummary {
        <ScenarioResultSummary as ::protobuf::Message>::default_instance()
    }
}

impl ScenarioResultSummary {
    pub fn new() -> ScenarioResultSummary {
        ::std::default::Default::default()
    }

    // double qps = 1;


    pub fn get_qps(&self) -> f64 {
        self.qps
    }
    pub fn clear_qps(&mut self) {
        self.qps = 0.;
    }

    // Param is passed by value, moved
    pub fn set_qps(&mut self, v: f64) {
        self.qps = v;
    }

    // double qps_per_server_core = 2;


    pub fn get_qps_per_server_core(&self) -> f64 {
        self.qps_per_server_core
    }
    pub fn clear_qps_per_server_core(&mut self) {
        self.qps_per_server_core = 0.;
    }

    // Param is passed by value, moved
    pub fn set_qps_per_server_core(&mut self, v: f64) {
        self.qps_per_server_core = v;
    }

    // double server_system_time = 3;


    pub fn get_server_system_time(&self) -> f64 {
        self.server_system_time
    }
    pub fn clear_server_system_time(&mut self) {
        self.server_system_time = 0.;
    }

    // Param is passed by value, moved
    pub fn set_server_system_time(&mut self, v: f64) {
        self.server_system_time = v;
    }

    // double server_user_time = 4;


    pub fn get_server_user_time(&self) -> f64 {
        self.server_user_time
    }
    pub fn clear_server_user_time(&mut self) {
        self.server_user_time = 0.;
    }

    // Param is passed by value, moved
    pub fn set_server_user_time(&mut self, v: f64) {
        self.server_user_time = v;
    }

    // double client_system_time = 5;


    pub fn get_client_system_time(&self) -> f64 {
        self.client_system_time
    }
    pub fn clear_client_system_time(&mut self) {
        self.client_system_time = 0.;
    }

    // Param is passed by value, moved
    pub fn set_client_system_time(&mut self, v: f64) {
        self.client_system_time = v;
    }

    // double client_user_time = 6;


    pub fn get_client_user_time(&self) -> f64 {
        self.client_user_time
    }
    pub fn clear_client_user_time(&mut self) {
        self.client_user_time = 0.;
    }

    // Param is passed by value, moved
    pub fn set_client_user_time(&mut self, v: f64) {
        self.client_user_time = v;
    }

    // double latency_50 = 7;


    pub fn get_latency_50(&self) -> f64 {
        self.latency_50
    }
    pub fn clear_latency_50(&mut self) {
        self.latency_50 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_latency_50(&mut self, v: f64) {
        self.latency_50 = v;
    }

    // double latency_90 = 8;


    pub fn get_latency_90(&self) -> f64 {
        self.latency_90
    }
    pub fn clear_latency_90(&mut self) {
        self.latency_90 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_latency_90(&mut self, v: f64) {
        self.latency_90 = v;
    }

    // double latency_95 = 9;


    pub fn get_latency_95(&self) -> f64 {
        self.latency_95
    }
    pub fn clear_latency_95(&mut self) {
        self.latency_95 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_latency_95(&mut self, v: f64) {
        self.latency_95 = v;
    }

    // double latency_99 = 10;


    pub fn get_latency_99(&self) -> f64 {
        self.latency_99
    }
    pub fn clear_latency_99(&mut self) {
        self.latency_99 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_latency_99(&mut self, v: f64) {
        self.latency_99 = v;
    }

    // double latency_999 = 11;


    pub fn get_latency_999(&self) -> f64 {
        self.latency_999
    }
    pub fn clear_latency_999(&mut self) {
        self.latency_999 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_latency_999(&mut self, v: f64) {
        self.latency_999 = v;
    }

    // double server_cpu_usage = 12;


    pub fn get_server_cpu_usage(&self) -> f64 {
        self.server_cpu_usage
    }
    pub fn clear_server_cpu_usage(&mut self) {
        self.server_cpu_usage = 0.;
    }

    // Param is passed by value, moved
    pub fn set_server_cpu_usage(&mut self, v: f64) {
        self.server_cpu_usage = v;
    }

    // double successful_requests_per_second = 13;


    pub fn get_successful_requests_per_second(&self) -> f64 {
        self.successful_requests_per_second
    }
    pub fn clear_successful_requests_per_second(&mut self) {
        self.successful_requests_per_second = 0.;
    }

    // Param is passed by value, moved
    pub fn set_successful_requests_per_second(&mut self, v: f64) {
        self.successful_requests_per_second = v;
    }

    // double failed_requests_per_second = 14;


    pub fn get_failed_requests_per_second(&self) -> f64 {
        self.failed_requests_per_second
    }
    pub fn clear_failed_requests_per_second(&mut self) {
        self.failed_requests_per_second = 0.;
    }

    // Param is passed by value, moved
    pub fn set_failed_requests_per_second(&mut self, v: f64) {
        self.failed_requests_per_second = v;
    }

    // double client_polls_per_request = 15;


    pub fn get_client_polls_per_request(&self) -> f64 {
        self.client_polls_per_request
    }
    pub fn clear_client_polls_per_request(&mut self) {
        self.client_polls_per_request = 0.;
    }

    // Param is passed by value, moved
    pub fn set_client_polls_per_request(&mut self, v: f64) {
        self.client_polls_per_request = v;
    }

    // double server_polls_per_request = 16;


    pub fn get_server_polls_per_request(&self) -> f64 {
        self.server_polls_per_request
    }
    pub fn clear_server_polls_per_request(&mut self) {
        self.server_polls_per_request = 0.;
    }

    // Param is passed by value, moved
    pub fn set_server_polls_per_request(&mut self, v: f64) {
        self.server_polls_per_request = v;
    }

    // double server_queries_per_cpu_sec = 17;


    pub fn get_server_queries_per_cpu_sec(&self) -> f64 {
        self.server_queries_per_cpu_sec
    }
    pub fn clear_server_queries_per_cpu_sec(&mut self) {
        self.server_queries_per_cpu_sec = 0.;
    }

    // Param is passed by value, moved
    pub fn set_server_queries_per_cpu_sec(&mut self, v: f64) {
        self.server_queries_per_cpu_sec = v;
    }

    // double client_queries_per_cpu_sec = 18;


    pub fn get_client_queries_per_cpu_sec(&self) -> f64 {
        self.client_queries_per_cpu_sec
    }
    pub fn clear_client_queries_per_cpu_sec(&mut self) {
        self.client_queries_per_cpu_sec = 0.;
    }

    // Param is passed by value, moved
    pub fn set_client_queries_per_cpu_sec(&mut self, v: f64) {
        self.client_queries_per_cpu_sec = v;
    }
}

impl ::protobuf::Message for ScenarioResultSummary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.qps = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.qps_per_server_core = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.server_system_time = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.server_user_time = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.client_system_time = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.client_user_time = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.latency_50 = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.latency_90 = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.latency_95 = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.latency_99 = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.latency_999 = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.server_cpu_usage = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.successful_requests_per_second = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.failed_requests_per_second = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.client_polls_per_request = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.server_polls_per_request = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.server_queries_per_cpu_sec = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.client_queries_per_cpu_sec = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.qps != 0. {
            my_size += 9;
        }
        if self.qps_per_server_core != 0. {
            my_size += 9;
        }
        if self.server_system_time != 0. {
            my_size += 9;
        }
        if self.server_user_time != 0. {
            my_size += 9;
        }
        if self.client_system_time != 0. {
            my_size += 9;
        }
        if self.client_user_time != 0. {
            my_size += 9;
        }
        if self.latency_50 != 0. {
            my_size += 9;
        }
        if self.latency_90 != 0. {
            my_size += 9;
        }
        if self.latency_95 != 0. {
            my_size += 9;
        }
        if self.latency_99 != 0. {
            my_size += 9;
        }
        if self.latency_999 != 0. {
            my_size += 9;
        }
        if self.server_cpu_usage != 0. {
            my_size += 9;
        }
        if self.successful_requests_per_second != 0. {
            my_size += 9;
        }
        if self.failed_requests_per_second != 0. {
            my_size += 9;
        }
        if self.client_polls_per_request != 0. {
            my_size += 9;
        }
        if self.server_polls_per_request != 0. {
            my_size += 10;
        }
        if self.server_queries_per_cpu_sec != 0. {
            my_size += 10;
        }
        if self.client_queries_per_cpu_sec != 0. {
            my_size += 10;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.qps != 0. {
            os.write_double(1, self.qps)?;
        }
        if self.qps_per_server_core != 0. {
            os.write_double(2, self.qps_per_server_core)?;
        }
        if self.server_system_time != 0. {
            os.write_double(3, self.server_system_time)?;
        }
        if self.server_user_time != 0. {
            os.write_double(4, self.server_user_time)?;
        }
        if self.client_system_time != 0. {
            os.write_double(5, self.client_system_time)?;
        }
        if self.client_user_time != 0. {
            os.write_double(6, self.client_user_time)?;
        }
        if self.latency_50 != 0. {
            os.write_double(7, self.latency_50)?;
        }
        if self.latency_90 != 0. {
            os.write_double(8, self.latency_90)?;
        }
        if self.latency_95 != 0. {
            os.write_double(9, self.latency_95)?;
        }
        if self.latency_99 != 0. {
            os.write_double(10, self.latency_99)?;
        }
        if self.latency_999 != 0. {
            os.write_double(11, self.latency_999)?;
        }
        if self.server_cpu_usage != 0. {
            os.write_double(12, self.server_cpu_usage)?;
        }
        if self.successful_requests_per_second != 0. {
            os.write_double(13, self.successful_requests_per_second)?;
        }
        if self.failed_requests_per_second != 0. {
            os.write_double(14, self.failed_requests_per_second)?;
        }
        if self.client_polls_per_request != 0. {
            os.write_double(15, self.client_polls_per_request)?;
        }
        if self.server_polls_per_request != 0. {
            os.write_double(16, self.server_polls_per_request)?;
        }
        if self.server_queries_per_cpu_sec != 0. {
            os.write_double(17, self.server_queries_per_cpu_sec)?;
        }
        if self.client_queries_per_cpu_sec != 0. {
            os.write_double(18, self.client_queries_per_cpu_sec)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScenarioResultSummary {
        ScenarioResultSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "qps",
                    |m: &ScenarioResultSummary| { &m.qps },
                    |m: &mut ScenarioResultSummary| { &mut m.qps },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "qps_per_server_core",
                    |m: &ScenarioResultSummary| { &m.qps_per_server_core },
                    |m: &mut ScenarioResultSummary| { &mut m.qps_per_server_core },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "server_system_time",
                    |m: &ScenarioResultSummary| { &m.server_system_time },
                    |m: &mut ScenarioResultSummary| { &mut m.server_system_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "server_user_time",
                    |m: &ScenarioResultSummary| { &m.server_user_time },
                    |m: &mut ScenarioResultSummary| { &mut m.server_user_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "client_system_time",
                    |m: &ScenarioResultSummary| { &m.client_system_time },
                    |m: &mut ScenarioResultSummary| { &mut m.client_system_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "client_user_time",
                    |m: &ScenarioResultSummary| { &m.client_user_time },
                    |m: &mut ScenarioResultSummary| { &mut m.client_user_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "latency_50",
                    |m: &ScenarioResultSummary| { &m.latency_50 },
                    |m: &mut ScenarioResultSummary| { &mut m.latency_50 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "latency_90",
                    |m: &ScenarioResultSummary| { &m.latency_90 },
                    |m: &mut ScenarioResultSummary| { &mut m.latency_90 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "latency_95",
                    |m: &ScenarioResultSummary| { &m.latency_95 },
                    |m: &mut ScenarioResultSummary| { &mut m.latency_95 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "latency_99",
                    |m: &ScenarioResultSummary| { &m.latency_99 },
                    |m: &mut ScenarioResultSummary| { &mut m.latency_99 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "latency_999",
                    |m: &ScenarioResultSummary| { &m.latency_999 },
                    |m: &mut ScenarioResultSummary| { &mut m.latency_999 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "server_cpu_usage",
                    |m: &ScenarioResultSummary| { &m.server_cpu_usage },
                    |m: &mut ScenarioResultSummary| { &mut m.server_cpu_usage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "successful_requests_per_second",
                    |m: &ScenarioResultSummary| { &m.successful_requests_per_second },
                    |m: &mut ScenarioResultSummary| { &mut m.successful_requests_per_second },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "failed_requests_per_second",
                    |m: &ScenarioResultSummary| { &m.failed_requests_per_second },
                    |m: &mut ScenarioResultSummary| { &mut m.failed_requests_per_second },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "client_polls_per_request",
                    |m: &ScenarioResultSummary| { &m.client_polls_per_request },
                    |m: &mut ScenarioResultSummary| { &mut m.client_polls_per_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "server_polls_per_request",
                    |m: &ScenarioResultSummary| { &m.server_polls_per_request },
                    |m: &mut ScenarioResultSummary| { &mut m.server_polls_per_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "server_queries_per_cpu_sec",
                    |m: &ScenarioResultSummary| { &m.server_queries_per_cpu_sec },
                    |m: &mut ScenarioResultSummary| { &mut m.server_queries_per_cpu_sec },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "client_queries_per_cpu_sec",
                    |m: &ScenarioResultSummary| { &m.client_queries_per_cpu_sec },
                    |m: &mut ScenarioResultSummary| { &mut m.client_queries_per_cpu_sec },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScenarioResultSummary>(
                    "ScenarioResultSummary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ScenarioResultSummary {
        static mut instance: ::protobuf::lazy::Lazy<ScenarioResultSummary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScenarioResultSummary,
        };
        unsafe {
            instance.get(ScenarioResultSummary::new)
        }
    }
}

impl ::protobuf::Clear for ScenarioResultSummary {
    fn clear(&mut self) {
        self.qps = 0.;
        self.qps_per_server_core = 0.;
        self.server_system_time = 0.;
        self.server_user_time = 0.;
        self.client_system_time = 0.;
        self.client_user_time = 0.;
        self.latency_50 = 0.;
        self.latency_90 = 0.;
        self.latency_95 = 0.;
        self.latency_99 = 0.;
        self.latency_999 = 0.;
        self.server_cpu_usage = 0.;
        self.successful_requests_per_second = 0.;
        self.failed_requests_per_second = 0.;
        self.client_polls_per_request = 0.;
        self.server_polls_per_request = 0.;
        self.server_queries_per_cpu_sec = 0.;
        self.client_queries_per_cpu_sec = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScenarioResultSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScenarioResultSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScenarioResult {
    // message fields
    pub scenario: ::protobuf::SingularPtrField<Scenario>,
    pub latencies: ::protobuf::SingularPtrField<super::stats::HistogramData>,
    pub client_stats: ::protobuf::RepeatedField<super::stats::ClientStats>,
    pub server_stats: ::protobuf::RepeatedField<super::stats::ServerStats>,
    pub server_cores: ::std::vec::Vec<i32>,
    pub summary: ::protobuf::SingularPtrField<ScenarioResultSummary>,
    pub client_success: ::std::vec::Vec<bool>,
    pub server_success: ::std::vec::Vec<bool>,
    pub request_results: ::protobuf::RepeatedField<super::stats::RequestResultCount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScenarioResult {
    fn default() -> &'a ScenarioResult {
        <ScenarioResult as ::protobuf::Message>::default_instance()
    }
}

impl ScenarioResult {
    pub fn new() -> ScenarioResult {
        ::std::default::Default::default()
    }

    // .grpc.testing.Scenario scenario = 1;


    pub fn get_scenario(&self) -> &Scenario {
        self.scenario.as_ref().unwrap_or_else(|| Scenario::default_instance())
    }
    pub fn clear_scenario(&mut self) {
        self.scenario.clear();
    }

    pub fn has_scenario(&self) -> bool {
        self.scenario.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scenario(&mut self, v: Scenario) {
        self.scenario = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scenario(&mut self) -> &mut Scenario {
        if self.scenario.is_none() {
            self.scenario.set_default();
        }
        self.scenario.as_mut().unwrap()
    }

    // Take field
    pub fn take_scenario(&mut self) -> Scenario {
        self.scenario.take().unwrap_or_else(|| Scenario::new())
    }

    // .grpc.testing.HistogramData latencies = 2;


    pub fn get_latencies(&self) -> &super::stats::HistogramData {
        self.latencies.as_ref().unwrap_or_else(|| super::stats::HistogramData::default_instance())
    }
    pub fn clear_latencies(&mut self) {
        self.latencies.clear();
    }

    pub fn has_latencies(&self) -> bool {
        self.latencies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latencies(&mut self, v: super::stats::HistogramData) {
        self.latencies = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_latencies(&mut self) -> &mut super::stats::HistogramData {
        if self.latencies.is_none() {
            self.latencies.set_default();
        }
        self.latencies.as_mut().unwrap()
    }

    // Take field
    pub fn take_latencies(&mut self) -> super::stats::HistogramData {
        self.latencies.take().unwrap_or_else(|| super::stats::HistogramData::new())
    }

    // repeated .grpc.testing.ClientStats client_stats = 3;


    pub fn get_client_stats(&self) -> &[super::stats::ClientStats] {
        &self.client_stats
    }
    pub fn clear_client_stats(&mut self) {
        self.client_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_stats(&mut self, v: ::protobuf::RepeatedField<super::stats::ClientStats>) {
        self.client_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_client_stats(&mut self) -> &mut ::protobuf::RepeatedField<super::stats::ClientStats> {
        &mut self.client_stats
    }

    // Take field
    pub fn take_client_stats(&mut self) -> ::protobuf::RepeatedField<super::stats::ClientStats> {
        ::std::mem::replace(&mut self.client_stats, ::protobuf::RepeatedField::new())
    }

    // repeated .grpc.testing.ServerStats server_stats = 4;


    pub fn get_server_stats(&self) -> &[super::stats::ServerStats] {
        &self.server_stats
    }
    pub fn clear_server_stats(&mut self) {
        self.server_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_stats(&mut self, v: ::protobuf::RepeatedField<super::stats::ServerStats>) {
        self.server_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_server_stats(&mut self) -> &mut ::protobuf::RepeatedField<super::stats::ServerStats> {
        &mut self.server_stats
    }

    // Take field
    pub fn take_server_stats(&mut self) -> ::protobuf::RepeatedField<super::stats::ServerStats> {
        ::std::mem::replace(&mut self.server_stats, ::protobuf::RepeatedField::new())
    }

    // repeated int32 server_cores = 5;


    pub fn get_server_cores(&self) -> &[i32] {
        &self.server_cores
    }
    pub fn clear_server_cores(&mut self) {
        self.server_cores.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_cores(&mut self, v: ::std::vec::Vec<i32>) {
        self.server_cores = v;
    }

    // Mutable pointer to the field.
    pub fn mut_server_cores(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.server_cores
    }

    // Take field
    pub fn take_server_cores(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.server_cores, ::std::vec::Vec::new())
    }

    // .grpc.testing.ScenarioResultSummary summary = 6;


    pub fn get_summary(&self) -> &ScenarioResultSummary {
        self.summary.as_ref().unwrap_or_else(|| ScenarioResultSummary::default_instance())
    }
    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ScenarioResultSummary) {
        self.summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut ScenarioResultSummary {
        if self.summary.is_none() {
            self.summary.set_default();
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ScenarioResultSummary {
        self.summary.take().unwrap_or_else(|| ScenarioResultSummary::new())
    }

    // repeated bool client_success = 7;


    pub fn get_client_success(&self) -> &[bool] {
        &self.client_success
    }
    pub fn clear_client_success(&mut self) {
        self.client_success.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_success(&mut self, v: ::std::vec::Vec<bool>) {
        self.client_success = v;
    }

    // Mutable pointer to the field.
    pub fn mut_client_success(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.client_success
    }

    // Take field
    pub fn take_client_success(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.client_success, ::std::vec::Vec::new())
    }

    // repeated bool server_success = 8;


    pub fn get_server_success(&self) -> &[bool] {
        &self.server_success
    }
    pub fn clear_server_success(&mut self) {
        self.server_success.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_success(&mut self, v: ::std::vec::Vec<bool>) {
        self.server_success = v;
    }

    // Mutable pointer to the field.
    pub fn mut_server_success(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.server_success
    }

    // Take field
    pub fn take_server_success(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.server_success, ::std::vec::Vec::new())
    }

    // repeated .grpc.testing.RequestResultCount request_results = 9;


    pub fn get_request_results(&self) -> &[super::stats::RequestResultCount] {
        &self.request_results
    }
    pub fn clear_request_results(&mut self) {
        self.request_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_results(&mut self, v: ::protobuf::RepeatedField<super::stats::RequestResultCount>) {
        self.request_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_results(&mut self) -> &mut ::protobuf::RepeatedField<super::stats::RequestResultCount> {
        &mut self.request_results
    }

    // Take field
    pub fn take_request_results(&mut self) -> ::protobuf::RepeatedField<super::stats::RequestResultCount> {
        ::std::mem::replace(&mut self.request_results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ScenarioResult {
    fn is_initialized(&self) -> bool {
        for v in &self.scenario {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.latencies {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.client_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.server_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.summary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scenario)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.latencies)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.client_stats)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.server_stats)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.server_cores)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.summary)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.client_success)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.server_success)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.request_results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.scenario.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.latencies.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.client_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.server_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.server_cores {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 2 * self.client_success.len() as u32;
        my_size += 2 * self.server_success.len() as u32;
        for value in &self.request_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.scenario.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.latencies.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.client_stats {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.server_stats {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.server_cores {
            os.write_int32(5, *v)?;
        };
        if let Some(ref v) = self.summary.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.client_success {
            os.write_bool(7, *v)?;
        };
        for v in &self.server_success {
            os.write_bool(8, *v)?;
        };
        for v in &self.request_results {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScenarioResult {
        ScenarioResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Scenario>>(
                    "scenario",
                    |m: &ScenarioResult| { &m.scenario },
                    |m: &mut ScenarioResult| { &mut m.scenario },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::stats::HistogramData>>(
                    "latencies",
                    |m: &ScenarioResult| { &m.latencies },
                    |m: &mut ScenarioResult| { &mut m.latencies },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::stats::ClientStats>>(
                    "client_stats",
                    |m: &ScenarioResult| { &m.client_stats },
                    |m: &mut ScenarioResult| { &mut m.client_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::stats::ServerStats>>(
                    "server_stats",
                    |m: &ScenarioResult| { &m.server_stats },
                    |m: &mut ScenarioResult| { &mut m.server_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "server_cores",
                    |m: &ScenarioResult| { &m.server_cores },
                    |m: &mut ScenarioResult| { &mut m.server_cores },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScenarioResultSummary>>(
                    "summary",
                    |m: &ScenarioResult| { &m.summary },
                    |m: &mut ScenarioResult| { &mut m.summary },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "client_success",
                    |m: &ScenarioResult| { &m.client_success },
                    |m: &mut ScenarioResult| { &mut m.client_success },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "server_success",
                    |m: &ScenarioResult| { &m.server_success },
                    |m: &mut ScenarioResult| { &mut m.server_success },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::stats::RequestResultCount>>(
                    "request_results",
                    |m: &ScenarioResult| { &m.request_results },
                    |m: &mut ScenarioResult| { &mut m.request_results },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScenarioResult>(
                    "ScenarioResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ScenarioResult {
        static mut instance: ::protobuf::lazy::Lazy<ScenarioResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScenarioResult,
        };
        unsafe {
            instance.get(ScenarioResult::new)
        }
    }
}

impl ::protobuf::Clear for ScenarioResult {
    fn clear(&mut self) {
        self.scenario.clear();
        self.latencies.clear();
        self.client_stats.clear();
        self.server_stats.clear();
        self.server_cores.clear();
        self.summary.clear();
        self.client_success.clear();
        self.server_success.clear();
        self.request_results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScenarioResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScenarioResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClientType {
    SYNC_CLIENT = 0,
    ASYNC_CLIENT = 1,
    OTHER_CLIENT = 2,
}

impl ::protobuf::ProtobufEnum for ClientType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientType> {
        match value {
            0 => ::std::option::Option::Some(ClientType::SYNC_CLIENT),
            1 => ::std::option::Option::Some(ClientType::ASYNC_CLIENT),
            2 => ::std::option::Option::Some(ClientType::OTHER_CLIENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClientType] = &[
            ClientType::SYNC_CLIENT,
            ClientType::ASYNC_CLIENT,
            ClientType::OTHER_CLIENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ClientType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ClientType {
}

impl ::std::default::Default for ClientType {
    fn default() -> Self {
        ClientType::SYNC_CLIENT
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ServerType {
    SYNC_SERVER = 0,
    ASYNC_SERVER = 1,
    ASYNC_GENERIC_SERVER = 2,
    OTHER_SERVER = 3,
}

impl ::protobuf::ProtobufEnum for ServerType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServerType> {
        match value {
            0 => ::std::option::Option::Some(ServerType::SYNC_SERVER),
            1 => ::std::option::Option::Some(ServerType::ASYNC_SERVER),
            2 => ::std::option::Option::Some(ServerType::ASYNC_GENERIC_SERVER),
            3 => ::std::option::Option::Some(ServerType::OTHER_SERVER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServerType] = &[
            ServerType::SYNC_SERVER,
            ServerType::ASYNC_SERVER,
            ServerType::ASYNC_GENERIC_SERVER,
            ServerType::OTHER_SERVER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ServerType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ServerType {
}

impl ::std::default::Default for ServerType {
    fn default() -> Self {
        ServerType::SYNC_SERVER
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RpcType {
    UNARY = 0,
    STREAMING = 1,
    STREAMING_FROM_CLIENT = 2,
    STREAMING_FROM_SERVER = 3,
    STREAMING_BOTH_WAYS = 4,
}

impl ::protobuf::ProtobufEnum for RpcType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RpcType> {
        match value {
            0 => ::std::option::Option::Some(RpcType::UNARY),
            1 => ::std::option::Option::Some(RpcType::STREAMING),
            2 => ::std::option::Option::Some(RpcType::STREAMING_FROM_CLIENT),
            3 => ::std::option::Option::Some(RpcType::STREAMING_FROM_SERVER),
            4 => ::std::option::Option::Some(RpcType::STREAMING_BOTH_WAYS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RpcType] = &[
            RpcType::UNARY,
            RpcType::STREAMING,
            RpcType::STREAMING_FROM_CLIENT,
            RpcType::STREAMING_FROM_SERVER,
            RpcType::STREAMING_BOTH_WAYS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RpcType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RpcType {
}

impl ::std::default::Default for RpcType {
    fn default() -> Self {
        RpcType::UNARY
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1agrpc/testing/control.proto\x12\x0cgrpc.testing\x1a\x1bgrpc/testing\
    /payloads.proto\x1a\x18grpc/testing/stats.proto\"2\n\rPoissonParams\x12!\
    \n\x0coffered_load\x18\x01\x20\x01(\x01R\x0bofferedLoad\"\x12\n\x10Close\
    dLoopParams\"\x90\x01\n\nLoadParams\x12A\n\x0bclosed_loop\x18\x01\x20\
    \x01(\x0b2\x1e.grpc.testing.ClosedLoopParamsH\0R\nclosedLoop\x127\n\x07p\
    oisson\x18\x02\x20\x01(\x0b2\x1b.grpc.testing.PoissonParamsH\0R\x07poiss\
    onB\x06\n\x04load\"\x7f\n\x0eSecurityParams\x12\x1e\n\x0buse_test_ca\x18\
    \x01\x20\x01(\x08R\tuseTestCa\x120\n\x14server_host_override\x18\x02\x20\
    \x01(\tR\x12serverHostOverride\x12\x1b\n\tcred_type\x18\x03\x20\x01(\tR\
    \x08credType\"g\n\nChannelArg\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04n\
    ame\x12\x1d\n\tstr_value\x18\x02\x20\x01(\tH\0R\x08strValue\x12\x1d\n\ti\
    nt_value\x18\x03\x20\x01(\x05H\0R\x08intValueB\x07\n\x05value\"\xc7\x06\
    \n\x0cClientConfig\x12%\n\x0eserver_targets\x18\x01\x20\x03(\tR\rserverT\
    argets\x129\n\x0bclient_type\x18\x02\x20\x01(\x0e2\x18.grpc.testing.Clie\
    ntTypeR\nclientType\x12E\n\x0fsecurity_params\x18\x03\x20\x01(\x0b2\x1c.\
    grpc.testing.SecurityParamsR\x0esecurityParams\x12?\n\x1coutstanding_rpc\
    s_per_channel\x18\x04\x20\x01(\x05R\x19outstandingRpcsPerChannel\x12'\n\
    \x0fclient_channels\x18\x05\x20\x01(\x05R\x0eclientChannels\x120\n\x14as\
    ync_client_threads\x18\x07\x20\x01(\x05R\x12asyncClientThreads\x120\n\
    \x08rpc_type\x18\x08\x20\x01(\x0e2\x15.grpc.testing.RpcTypeR\x07rpcType\
    \x129\n\x0bload_params\x18\n\x20\x01(\x0b2\x18.grpc.testing.LoadParamsR\
    \nloadParams\x12B\n\x0epayload_config\x18\x0b\x20\x01(\x0b2\x1b.grpc.tes\
    ting.PayloadConfigR\rpayloadConfig\x12H\n\x10histogram_params\x18\x0c\
    \x20\x01(\x0b2\x1d.grpc.testing.HistogramParamsR\x0fhistogramParams\x12\
    \x1b\n\tcore_list\x18\r\x20\x03(\x05R\x08coreList\x12\x1d\n\ncore_limit\
    \x18\x0e\x20\x01(\x05R\tcoreLimit\x12(\n\x10other_client_api\x18\x0f\x20\
    \x01(\tR\x0eotherClientApi\x12;\n\x0cchannel_args\x18\x10\x20\x03(\x0b2\
    \x18.grpc.testing.ChannelArgR\x0bchannelArgs\x12$\n\x0ethreads_per_cq\
    \x18\x11\x20\x01(\x05R\x0cthreadsPerCq\x12.\n\x13messages_per_stream\x18\
    \x12\x20\x01(\x05R\x11messagesPerStream\"?\n\x0cClientStatus\x12/\n\x05s\
    tats\x18\x01\x20\x01(\x0b2\x19.grpc.testing.ClientStatsR\x05stats\"\x1c\
    \n\x04Mark\x12\x14\n\x05reset\x18\x01\x20\x01(\x08R\x05reset\"u\n\nClien\
    tArgs\x122\n\x05setup\x18\x01\x20\x01(\x0b2\x1a.grpc.testing.ClientConfi\
    gH\0R\x05setup\x12(\n\x04mark\x18\x02\x20\x01(\x0b2\x12.grpc.testing.Mar\
    kH\0R\x04markB\t\n\x07argtype\"\x95\x04\n\x0cServerConfig\x129\n\x0bserv\
    er_type\x18\x01\x20\x01(\x0e2\x18.grpc.testing.ServerTypeR\nserverType\
    \x12E\n\x0fsecurity_params\x18\x02\x20\x01(\x0b2\x1c.grpc.testing.Securi\
    tyParamsR\x0esecurityParams\x12\x12\n\x04port\x18\x04\x20\x01(\x05R\x04p\
    ort\x120\n\x14async_server_threads\x18\x07\x20\x01(\x05R\x12asyncServerT\
    hreads\x12\x1d\n\ncore_limit\x18\x08\x20\x01(\x05R\tcoreLimit\x12B\n\x0e\
    payload_config\x18\t\x20\x01(\x0b2\x1b.grpc.testing.PayloadConfigR\rpayl\
    oadConfig\x12\x1b\n\tcore_list\x18\n\x20\x03(\x05R\x08coreList\x12(\n\
    \x10other_server_api\x18\x0b\x20\x01(\tR\x0eotherServerApi\x12$\n\x0ethr\
    eads_per_cq\x18\x0c\x20\x01(\x05R\x0cthreadsPerCq\x12/\n\x13resource_quo\
    ta_size\x18\xe9\x07\x20\x01(\x05R\x11resourceQuotaSize\x12<\n\x0cchannel\
    _args\x18\xea\x07\x20\x03(\x0b2\x18.grpc.testing.ChannelArgR\x0bchannelA\
    rgs\"u\n\nServerArgs\x122\n\x05setup\x18\x01\x20\x01(\x0b2\x1a.grpc.test\
    ing.ServerConfigH\0R\x05setup\x12(\n\x04mark\x18\x02\x20\x01(\x0b2\x12.g\
    rpc.testing.MarkH\0R\x04markB\t\n\x07argtype\"i\n\x0cServerStatus\x12/\n\
    \x05stats\x18\x01\x20\x01(\x0b2\x19.grpc.testing.ServerStatsR\x05stats\
    \x12\x12\n\x04port\x18\x02\x20\x01(\x05R\x04port\x12\x14\n\x05cores\x18\
    \x03\x20\x01(\x05R\x05cores\"\r\n\x0bCoreRequest\"$\n\x0cCoreResponse\
    \x12\x14\n\x05cores\x18\x01\x20\x01(\x05R\x05cores\"\x06\n\x04Void\"\xef\
    \x02\n\x08Scenario\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12?\n\
    \rclient_config\x18\x02\x20\x01(\x0b2\x1a.grpc.testing.ClientConfigR\x0c\
    clientConfig\x12\x1f\n\x0bnum_clients\x18\x03\x20\x01(\x05R\nnumClients\
    \x12?\n\rserver_config\x18\x04\x20\x01(\x0b2\x1a.grpc.testing.ServerConf\
    igR\x0cserverConfig\x12\x1f\n\x0bnum_servers\x18\x05\x20\x01(\x05R\nnumS\
    ervers\x12%\n\x0ewarmup_seconds\x18\x06\x20\x01(\x05R\rwarmupSeconds\x12\
    +\n\x11benchmark_seconds\x18\x07\x20\x01(\x05R\x10benchmarkSeconds\x127\
    \n\x18spawn_local_worker_count\x18\x08\x20\x01(\x05R\x15spawnLocalWorker\
    Count\"A\n\tScenarios\x124\n\tscenarios\x18\x01\x20\x03(\x0b2\x16.grpc.t\
    esting.ScenarioR\tscenarios\"\xbb\x06\n\x15ScenarioResultSummary\x12\x10\
    \n\x03qps\x18\x01\x20\x01(\x01R\x03qps\x12-\n\x13qps_per_server_core\x18\
    \x02\x20\x01(\x01R\x10qpsPerServerCore\x12,\n\x12server_system_time\x18\
    \x03\x20\x01(\x01R\x10serverSystemTime\x12(\n\x10server_user_time\x18\
    \x04\x20\x01(\x01R\x0eserverUserTime\x12,\n\x12client_system_time\x18\
    \x05\x20\x01(\x01R\x10clientSystemTime\x12(\n\x10client_user_time\x18\
    \x06\x20\x01(\x01R\x0eclientUserTime\x12\x1d\n\nlatency_50\x18\x07\x20\
    \x01(\x01R\tlatency50\x12\x1d\n\nlatency_90\x18\x08\x20\x01(\x01R\tlaten\
    cy90\x12\x1d\n\nlatency_95\x18\t\x20\x01(\x01R\tlatency95\x12\x1d\n\nlat\
    ency_99\x18\n\x20\x01(\x01R\tlatency99\x12\x1f\n\x0blatency_999\x18\x0b\
    \x20\x01(\x01R\nlatency999\x12(\n\x10server_cpu_usage\x18\x0c\x20\x01(\
    \x01R\x0eserverCpuUsage\x12C\n\x1esuccessful_requests_per_second\x18\r\
    \x20\x01(\x01R\x1bsuccessfulRequestsPerSecond\x12;\n\x1afailed_requests_\
    per_second\x18\x0e\x20\x01(\x01R\x17failedRequestsPerSecond\x127\n\x18cl\
    ient_polls_per_request\x18\x0f\x20\x01(\x01R\x15clientPollsPerRequest\
    \x127\n\x18server_polls_per_request\x18\x10\x20\x01(\x01R\x15serverPolls\
    PerRequest\x12:\n\x1aserver_queries_per_cpu_sec\x18\x11\x20\x01(\x01R\
    \x16serverQueriesPerCpuSec\x12:\n\x1aclient_queries_per_cpu_sec\x18\x12\
    \x20\x01(\x01R\x16clientQueriesPerCpuSec\"\xf6\x03\n\x0eScenarioResult\
    \x122\n\x08scenario\x18\x01\x20\x01(\x0b2\x16.grpc.testing.ScenarioR\x08\
    scenario\x129\n\tlatencies\x18\x02\x20\x01(\x0b2\x1b.grpc.testing.Histog\
    ramDataR\tlatencies\x12<\n\x0cclient_stats\x18\x03\x20\x03(\x0b2\x19.grp\
    c.testing.ClientStatsR\x0bclientStats\x12<\n\x0cserver_stats\x18\x04\x20\
    \x03(\x0b2\x19.grpc.testing.ServerStatsR\x0bserverStats\x12!\n\x0cserver\
    _cores\x18\x05\x20\x03(\x05R\x0bserverCores\x12=\n\x07summary\x18\x06\
    \x20\x01(\x0b2#.grpc.testing.ScenarioResultSummaryR\x07summary\x12%\n\
    \x0eclient_success\x18\x07\x20\x03(\x08R\rclientSuccess\x12%\n\x0eserver\
    _success\x18\x08\x20\x03(\x08R\rserverSuccess\x12I\n\x0frequest_results\
    \x18\t\x20\x03(\x0b2\x20.grpc.testing.RequestResultCountR\x0erequestResu\
    lts*A\n\nClientType\x12\x0f\n\x0bSYNC_CLIENT\x10\0\x12\x10\n\x0cASYNC_CL\
    IENT\x10\x01\x12\x10\n\x0cOTHER_CLIENT\x10\x02*[\n\nServerType\x12\x0f\n\
    \x0bSYNC_SERVER\x10\0\x12\x10\n\x0cASYNC_SERVER\x10\x01\x12\x18\n\x14ASY\
    NC_GENERIC_SERVER\x10\x02\x12\x10\n\x0cOTHER_SERVER\x10\x03*r\n\x07RpcTy\
    pe\x12\t\n\x05UNARY\x10\0\x12\r\n\tSTREAMING\x10\x01\x12\x19\n\x15STREAM\
    ING_FROM_CLIENT\x10\x02\x12\x19\n\x15STREAMING_FROM_SERVER\x10\x03\x12\
    \x17\n\x13STREAMING_BOTH_WAYS\x10\x04b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
